
<?xml version="1.0" standalone="yes"?>
<!--
UniCC LALR(1) Parser Generator
Copyright (C) 2006-2009 by Phorward Software Technologies, Jan Max Meyer
http://www.phorward-software.com ++ mail@phorward-software.com

File:		C.xml
Version:	1.6
Author:		Jan Max Meyer
Usage:		Target language template for the C programming language

This template should serve as a general description/reference of how
templates for the UniCC parser generator are written. I know that some
things could be done better, and that there are many ways to speed up
the parsers UniCC produces. If you know some ways, please improve it!

Some general things you have to know:
-	The placeholder @@prefix holds the prefix which is possibly defined for
	a grammar. You can use @@prefix everywhere!
-	No tag is 'really' required. UniCC will give a warning when it misses a
	tag, but continues code generation with the tags it found.

-->

<generator name="C">
	<!--
	***********************************************************************************************
	Escape sequences
	***********************************************************************************************
	These are the escapable sequence definitions for the target language
	which should be replaced when terminal-/nonterminal (especially generated
	ones) names are generated into the target file, e.g. in the <symbols>-tag.
	-->
	<escape-sequence for="\" do="\\" />
	<escape-sequence for="&#x22;" do="\&#x22;" />
	
	<!--
	***********************************************************************************************
	Value-stack related definitions
	***********************************************************************************************
	-->

	<!-- Default (return) value type for nonterminals -->
	<vstack_def_type>int</vstack_def_type>
	<!-- Default value type for character-class terminals -->
	<vstack_term_type>int</vstack_term_type>
	
	<!--
	Code to be generated for the value stack datatype-definition when only one datatype is used
	within the whole grammar (or if always the default-type is used).
	
	Placeholders:		@@value-type			- 	Expands to the type-declaration of the only
													used value type.
	-->
	<vstack_single>typedef @@value-type @@prefix_vtype;</vstack_single>

	<!--
	Begin and end of code to be generated for the value stack datatype-definition when multiple
	datatypes are used within the whole grammar.
	Note that you can define here even struct-like code or array-like structure if your target
	language supports only those.
	
	Placeholders:		@@number-of-value-types	-	Expands to the maximum number of value types
													possible here. Can be used in both of the 
													following tags.
	-->
	<vstack_union_start>typedef union @@prefix_VTYPE&#x0A;{&#x0A;</vstack_union_start>
	<vstack_union_end>} @@prefix_vtype;&#x0A;&#x0A;</vstack_union_end>
	
	<!--
	This tag defines a data type definition within the union. As @@attribute, the content of the
	<vstack_union_att>-tag is expanded, which then contains a consecutive number of the datatype.
	This block is repeated for every value type within the union/whatever ;)
	
	Placeholders:		@@value-type			- 	Expands to the type-declaration of the
													current data type as specified within the
													grammar.
						@@attribute				-	As @@attribute, the content of the
													<vstack_union_att>-tag is expanded, which
													then contains a consecutive number of the
													datatype.
						@@value-type-id			-	The value type ID, which begins at 0.
													This can be the index of an array!
	-->
	<vstack_union_def>&#x09;@@value-type @@attribute;&#x0A;</vstack_union_def>
	
	<!--
	This tag defines is used in several code-generation parts, both when the value stack union
	is defined and when reduction code for productions is produced.
	
	Placeholders:		@@value-type-id			-	The value type ID, which begins at 0.
													This can be the index of an array!
	-->
	<vstack_union_att>value_@@value-type-id</vstack_union_att>

	<!--
	***********************************************************************************************
	Reduction-code related definitions
	***********************************************************************************************
	-->
	
	<!--
	Begin and end of code to be generated for each reduction code action of a production. This
	code is embedded to a switch-structure below, every block is a "case" within this switch.
	<action_start> is generated BEFORE and <action_end> BEHIND each reduction code.
	
	Placeholders:		@@production-number		-	The number of the production to be reduced.
													Can be used in both of the following tags.
	-->
	<action_start>&#x09;&#x09;&#x09;&#x09;case @@production-number:&#x09;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;</action_start>
	<action_end>&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x09;&#x09;&#x09;&#x09;break;&#x0A;&#x0A;</action_end>
	
	<!--
	Single value access when only one datatype is used in the whole grammar.
	
	Placeholders:		@@offset				-	The number of the right-hand side symbol to be
													accessed. This is the number specified in
													the production reduction code as number or
													even by the right-hand side element's identi-
													fier. The offset is inserted here by UniCC's
													code generator.
	-->
	<action_single>(*( pcb.vtos - @@offset ))</action_single>

	<!--
	Multiple value access, in case of different datatypes used within the grammar.
	
	Placeholders:		@@offset				-	The number of the right-hand side symbol to be
													accessed. This is the number specified in
													the production reduction code as number or
													even by the right-hand side element's identi-
													fier. The offset is inserted here by UniCC's
													code generator.
						@@attribute				-	As @@attribute, the content of the
													<vstack_union_att>-tag is expanded, which
													then contains a consecutive number of the
													datatype.
	-->
	<action_union>(*( pcb.vtos - @@offset )).@@attribute</action_union>

	<!--
	Single value left-hand side assignment variable when only one datatype is used in the whole
	grammar.
	
	Placeholders:		none
	-->
	<action_lhs_single>pcb.ret</action_lhs_single>

	<!--
	Multiple value left-hand side assignment variable when different datatypes are used within
	the whole grammar.
	
	Placeholders:		@@attribute				-	As @@attribute, the content of the
													<vstack_union_att>-tag is expanded, which
													then contains a consecutive number of the
													datatype.
	-->
	<action_lhs_union>pcb.ret.@@attribute</action_lhs_union>

	<!--
	***********************************************************************************************
	Regular expression terminal match related definitions
	***********************************************************************************************
	-->
	
	<!--
	Begin and end of code to be generated for each match of a regular expression token. This
	code is embedded to a switch-structure below, every block is a "case" within this switch.
	<scan_action_start> is generated BEFORE and <scan_action_end> BEHIND each reduction code.
	The code here is only produced when the matched regex-terminal contains individual code
	segments.
	
	Placeholders:		@@symbol-number			-	The id of the terminal the lexical analyzer
													action belongs to.
													Can be used in both of the following tags.
	-->
	
			<scan_action_start>&#x09;&#x09;&#x09;&#x09;case @@symbol-number:&#x0A;&#x09;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;</scan_action_start>
			<scan_action_end>&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x09;&#x09;&#x09;&#x09;break;&#x0A;&#x0A;</scan_action_end>

	<!--
	The content of the tags <scan_action_begin_offset> and <scan_action_end_offset> are
	inserted in regex-terminal semantic code blocks for the placeholders @> and @< to
	get the start- and end-offset of the matched string. Normally, these are variable
	names.
	
	Placeholders:		none
	-->
	<scan_action_begin_offset>(pcb.buf)</scan_action_begin_offset>
	<scan_action_end_offset>(pcb.buf + pcb.len)</scan_action_end_offset>

	<!--
	When @@ is used in regex-terminal semantic code blocks, a variable that receives
	the semantic value of the token to be pushed to the value stack must be given.
	For single value assignments,this is done here. This value is only used when the
	grammar uses only one datatype.
	
	Placeholders:		none
	-->
	<scan_action_ret_single>*(pcb.vtos)</scan_action_ret_single>

	<!--
	Same play for multiple value assignments in regex-terminal semantic action blocks.
	
	Placeholders:		@@attribute				-	As @@attribute, the content of the
													<vstack_union_att>-tag is expanded, which
													then contains a consecutive number of the
													datatype.
	-->
	<scan_action_ret_union>(*(pcb.vtos)).@@attribute</scan_action_ret_union>

	<!--
	***********************************************************************************************
	Parse tables
	***********************************************************************************************
	-->
	
	<!--
	The <prodlen>-Tag defines an one-dimensional array for the production lengths, which means the
	number of items on a right-hand side of every production used within the grammar. This is used
	when a reduction occurs to pop the correct number of items off the parse stack.
	The Placeholders can only be used in the <col>-tag below <prodlen>.
	
	Placeholders:		@@length-of-rhs			-	Number of items on a production's
													right-hand side.
						@@production-number		-	The production id number identifying
													the production. This can be automatically
													solved via the array index itself. The
													production number begins at 0.
	-->
	<prodlen>
		<col>@@length-of-rhs</col>
		<col_sep>, </col_sep>
	</prodlen>

	<!--
	The <prodlhs>-Tag defines an one-dimensional array for the id's of the left-hand side each pro-
	duction belons to. This is used	when a reduction occurs to push the correct left-hand side symbol
	onto the parse stack. The Placeholders can only be used in the <col>-tag below <prodlhs>.
	
	Placeholders:		@@lhs					-	The id-number of the left-hand side symbol
													the production belons to.
						@@production-number		-	The production id number identifying
													the production. This can be automatically
													solved via the array index itself. The
													production number begins at 0.
	-->
	<prodlhs>
		<col>@@lhs</col>
		<col_sep>, </col_sep>
	</prodlhs>
	
	<!--
		The <defprod>-Tag defines an one-dimensional array for the id's of the default productions
		that should be reduced when no other action is selected. UniCC choses the default production
		by the most common reduction that comes up. All reductions which belong to that production
		are removed from the action table, so that the default table is chosen.
		The following Placeholders can only be used in the <col>-tag below <defprod>.
					
		Placeholders:		@@state-number			-	The id-number of the state where the
														default production belongs to.
							@@production-number		-	The production id number identifying
														the production. This can be automatically
														solved via the array index itself. The
														production number begins at 0. If there
														is no default-production, than the
														production-number will be -1.
	-->
	<defprod>
		<col>@@production-number</col>
		<col_sep>, </col_sep>
	</defprod>

	<!--
	The <charmap>-Tag defines an one-dimensional array for the id's of the left-hand side each pro-
	duction belons to. This is used	when a reduction occurs to push the correct left-hand side symbol
	onto the parse stack. The Placeholders can only be used in the <col>-tag below <prodlhs>.
	
	Placeholders:		@@lhs					-	The id-number of the left-hand side symbol
													the production belons to.
						@@production-number		-	The production id number identifying
													the production. This can be automatically
													solved via the array index itself. The
													production number begins at 0.
	-->
	<charmap>
		<col>@@symbol</col>
		<col_sep>, </col_sep>
	</charmap>
	<dfa_select>
		<col>@@machine</col>
		<col_sep>, </col_sep>
	</dfa_select>
	<dfa_char>
		<col>@@code</col>
		<col_sep>, </col_sep>
	</dfa_char>
	<dfa_trans>
		<col>@@goto</col>
		<col_sep>, </col_sep>
	</dfa_trans>
	<acttab>
		<row_start>&#x09;{ @@number-of-columns</row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>, @@symbol,@@action,@@index </col>
		<col_sep></col_sep>
	</acttab>
	<gotab>
		<row_start>&#x09;{ @@number-of-columns</row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>, @@symbol,@@action,@@index </col>
		<col_sep></col_sep>
	</gotab>
	<dfa_idx>
		<row_start>&#x09;{ </row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@index</col>
		<col_sep>, </col_sep>
	</dfa_idx>
	<dfa_accept>
		<row_start>&#x09;{ </row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@accept</col>
		<col_sep>, </col_sep>
	</dfa_accept>
	<kw_invalid_suffix>
		<col_true>1</col_true>
		<col_false>0</col_false>
		<col_sep>, </col_sep>
	</kw_invalid_suffix>
	<whitespace>
		<col_true>1</col_true>
		<col_false>0</col_false>
		<col_sep>, </col_sep>
	</whitespace>
	<symbols>
		<col>/* @@symbol */ "@@symbol-name"</col>
		<col_sep>, </col_sep>
	</symbols>
	<productions>
		<col>"@@production"</col>
		<col_sep>,&#x0A;</col_sep>
	</productions>
	<code_localization>#line @@line "@@filename"
</code_localization>
	<driver>/*
 * Parser:		@@name
 * Version:		@@version
 * Copyright:	@@copyright
 * Description:	@@description
 *
 * UniCC Parser Template for C - Version 1.6
 * Copyright (C) by Phorward Software Technologies, Jan Max Meyer
 */
 
#if @@prologue_len == 0
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#else
@@prologue
#endif


#ifndef UNICC_DEBUG
#define UNICC_DEBUG	0
#endif

#ifndef UNICC_STACKDEBUG
#define UNICC_STACKDEBUG	0
#endif

#ifndef UNICC_SRC_MOVE
#define UNICC_SRC_MOVE( l )	
#endif

#ifndef UNICC_PARSE_ERROR
#define UNICC_PARSE_ERROR( pcb ) \
	fprintf( stderr, "line %d: syntax error on token '%s'\n", \
		( pcb )->line, @@prefix_symbol_names[ ( pcb )->sym ] )
#endif

#ifndef UNICC_CLEARIN
#define UNICC_CLEARIN			@@prefix_clear_input( &amp;@@prefix_pcb )
#endif

/*TODO:*/
#ifndef UNICC_NO_INPUT_BUFFER
#define UNICC_NO_INPUT_BUFFER	0
#endif

#ifndef UNICC_GETINPUT
#define UNICC_GETINPUT			getchar()
#endif

#ifndef UNICC_MALLOCSTEP
#define UNICC_MALLOCSTEP		128
#endif

#ifndef UNICC_OUTOFMEM
#define UNICC_OUTOFMEM			fprintf( stderr, "Fatal error, ran out of memory\n" ),\
								exit( 1 )
#endif

#ifdef PARSERFILE
#undef PARSERFILE
#endif
#define PARSERFILE "@@prefix" "debug"

/* Value Types */
@@value-type-definition

/* Parser Control Block */
typedef struct
{
	/* Stack */
	int				stack	[ 1024 ];
	int*			tos;
	/* Value Stack */
	@@prefix_vtype	vstack	[ 1024 ];
	@@prefix_vtype*	vtos;
	
	/* Values */
	@@prefix_vtype	ret;
	@@prefix_vtype	test;
	
	/* State */
	int				act;
	int				idx;
	
	/* Lookahead */
	char*			buf;
	char*			bufend;
	char*			bufsize;

	int				sym;
	unsigned int	len;
	
	/* Error handling */
	int				error_delay;
	int				error_count;
	
	unsigned int	line;
	
	@@pcb
} @@prefix_pcb;

/* Action Table */
static int @@prefix_act[ @@number-of-states ][ @@deepest-action-row * 3 + 1 ] =
{
@@action-table
};

/* GoTo Table */
static int @@prefix_go[ @@number-of-states ][ @@deepest-goto-row * 3 + 1 ] =
{
@@goto-table
};

/* Production Lengths */
static int @@prefix_prod_lengths[ @@number-of-productions ] =
{
	@@production-lengths
};

/* Production's Left-Hand-Sides */
static int @@prefix_prod_lhs[ @@number-of-productions ] =
{
	@@production-lhs
};

/* Default productions per state */
static int @@prefix_def_prod[ @@number-of-states ] =
{
	@@default-productions
};

#if !@@model
/* DFA selection table */
static int @@prefix_dfa_select[ @@number-of-states ] =
{
	@@dfa-select
};
#endif

#if @@number-of-dfa-machines
/* DFA index table */
static int @@prefix_dfa_idx[ @@number-of-dfa-machines ][ @@deepest-dfa-index-row ] =
{
@@dfa-index
};

/* DFA transition chars */
static int @@prefix_dfa_chars[ @@size-of-dfa-characters ] =
{
	@@dfa-char
};

/* DFA transitions */
static int @@prefix_dfa_trans[ @@size-of-dfa-characters ] =
{
	@@dfa-trans
};

/* DFA acception states */
static int @@prefix_dfa_accept[ @@number-of-dfa-machines ][ @@deepest-dfa-accept-row ] =
{
@@dfa-accept
};

/* Invalid characters behind keywords */
static int @@prefix_kw_invalid_suffixes[ @@character-universe ] =
{
@@keyword-invalid-suffixes
};
#endif

/* Single Character Lookahead */
static int @@prefix_char_map[ @@character-universe ] =
{
	@@character-map
};

#if @@number-of-symbols
/* Whitespace symbols */
static int @@prefix_whitespaces[ @@number-of-symbols ] =
{
	@@whitespaces
};
#endif

/* *** DO NOT "#if UNICC_DEBUG" THIS!
       IT MAY BE USED FOR ERROR REPORTING!
*/

/* DEBUG: Symbol names */
static char* @@prefix_symbol_names[] =
{
	@@symbols
};

/* DEBUG: Productions */
static char* @@prefix_productions[] =
{
	@@productions
};

static int @@prefix_get_act_tab( @@prefix_pcb* pcb )
{
	int i;

	for( i = 1; i &lt; @@prefix_act[ *( pcb->tos ) ][0] * 3; i += 3 )
	{
		if( @@prefix_act[ *( pcb->tos ) ][i] == pcb->sym )
		{
			pcb->act = @@prefix_act[ *( pcb->tos ) ][i+1];
			pcb->idx = @@prefix_act[ *( pcb->tos ) ][i+2];
			return 1;
		}
	}
	
	/* Default production */
	if( ( pcb->idx = @@prefix_def_prod[ *( pcb->tos ) ] ) > -1 )
	{
		pcb->act = 1; /* Reduce */
		return 1;
	}

	return 0;
}

static int @@prefix_get_go_tab( @@prefix_pcb* pcb, int sym )
{
	int i;

	for( i = 1; i &lt; @@prefix_go[ *( pcb->tos ) ][0] * 3; i += 3 )
	{
		if( @@prefix_go[ *( pcb->tos ) ][i] == sym )
		{
			pcb->act = @@prefix_go[ *( pcb->tos ) ][i+1];
			pcb->idx = @@prefix_go[ *( pcb->tos ) ][i+2];
			return 1;
		}
	}

	return 0;
}

static char @@prefix_get_input( @@prefix_pcb* pcb, unsigned int offset )
{
	/*
	if( pcb->bufend &amp;&amp; pcb->buf + pcb->len &lt; pcb->bufend )
		return *( pcb->buf + pcb->len++ );
	*/
	
	while( pcb->buf + offset &gt;= pcb->bufend )
	{
		if( !pcb->buf )
		{
			pcb->bufend = pcb->buf = (char*)malloc(
				( UNICC_MALLOCSTEP + 1 ) * sizeof( char ) );		
	
			if( !pcb->buf )
				UNICC_OUTOFMEM;
	
			*pcb->buf = '\0';
		}
		else if( *pcb->buf &amp;&amp; !( ( pcb->bufend - pcb->buf ) % UNICC_MALLOCSTEP ) )
		{
			pcb->buf = (char*)realloc( (char*)pcb->buf,
				( ( pcb->bufend - pcb->buf ) + UNICC_MALLOCSTEP + 1 )
					* sizeof( char ) );
	
			if( !pcb->buf )
				UNICC_OUTOFMEM;
	
			pcb->bufend = pcb->buf + strlen( pcb->buf );
		}
	
		sprintf( pcb->bufend++, "%c", UNICC_GETINPUT );
	}

	/*
	#if UNICC_DEBUG
	fprintf( stderr, "reading &gt;%c&lt;\n", *( pcb->buf + offset ) );
	#endif
	*/
	return *( pcb->buf + offset );
}

static void @@prefix_clear_input( @@prefix_pcb* pcb )
{
	int		i;

	if( pcb->buf )
	{
		if( pcb->len )
		{
			for( i = 0; i &lt; pcb->len; i++ )
				if( pcb->buf[i] == '\n' )
					pcb->line++;

			strcpy( pcb->buf, pcb->buf + pcb->len );		
			pcb->bufend = pcb->buf + strlen( pcb->buf );
		}
		else
		{
			pcb->bufend = pcb->buf;
			*( pcb->buf ) = '\0';
		}
	}
	
	pcb->len = 0;
	pcb->sym = -1;
}

#if @@number-of-dfa-machines
static void @@prefix_get_keyword( @@prefix_pcb* pcb )
{
	int 	dfa_st	= 0;
	int		chr;
	int		len		= 0;
#if !@@model
	int		mach	= @@prefix_dfa_select[ *( pcb->tos ) ];
#else
	int		mach	= 0;
#endif
	char	next;

	next = @@prefix_get_input( pcb, len );

	do
	{
		chr = @@prefix_dfa_idx[ mach ][ dfa_st ];

		dfa_st = -1;
		while( @@prefix_dfa_chars[ chr ] &gt; -1 )
		{
			if( @@prefix_dfa_chars[ chr ] == next )
			{
				dfa_st = *( @@prefix_dfa_trans + chr );

				if( @@prefix_dfa_accept[ mach ][ dfa_st ] &gt; -1 )
					pcb->sym = @@prefix_dfa_accept[ mach ][ dfa_st ];

				next = @@prefix_get_input( pcb, ++len );
				break;
			}

			chr++;
		}
	}
	while( dfa_st &gt; -1 );
	
	if( pcb->sym &gt; -1 )
	{
		if( @@prefix_kw_invalid_suffixes[ next ] )
			pcb->sym = -1;
		else
			pcb->len = len;
	}
}
#endif

static int @@prefix_get_sym( @@prefix_pcb* pcb )
{
#if !@@model
	pcb->sym = -1;
	pcb->len = 0;
	
#else /* @@model */
	if( 1  ) /* pcb->sym == -1 */
	{
		do
		{
#endif /* @@model */

#if @@number-of-dfa-machines
#if !@@model
			if( @@prefix_dfa_select[ *( pcb->tos ) ] &gt; -1 )
				@@prefix_get_keyword( pcb );
#else
			@@prefix_get_keyword( pcb );
#endif /* !@@model */
			if( pcb->sym == -1 )
#endif /* @@number-of-dfa-machines */
				pcb->sym = @@prefix_char_map[ @@prefix_get_input( pcb, pcb->len++ ) ];
#if @@model

			if( pcb->sym &gt; -1 &amp;&amp; @@prefix_whitespaces[ pcb->sym ] )
			{
				@@prefix_clear_input( pcb );
				continue;
			}
			
			break;
		}
		while( 1 );
	}
#endif /* @@model */

	return ( pcb->sym > -1 ) ? 1 : 0;
}

#if UNICC_STACKDEBUG
static void @@prefix_dbg_stack( FILE* out, int* stack, int* tos,
	@@prefix_vtype* vstack, @@prefix_vtype* vtos )
{
	fprintf( out, "%s: Stack        ", PARSERFILE );
	for( ; stack &lt;= tos; stack++ )
		fprintf( out, "%d ", *stack );
		
	fprintf( out, "\n" );
	fprintf( out, "%s: Value-Stack  ", PARSERFILE );	
	for( ; vstack &lt;= vtos; vstack++ )
		fprintf( out, "%p ", &( vstack ) );
	
	fprintf( out, "\n" );
}
#endif /* UNICC_STACKDEBUG */

int @@prefix_parse( void )
{
	@@prefix_pcb		pcb;
	int					old_sym;
#if UNICC_DEBUG
	int		i;
	@@prefix_vtype*		vptr;
	FILE* 				@@prefix_dbg;
	
	@@prefix_dbg = stderr;
#endif

	/* Initialize Parser Control Block */
	memset( &pcb, 0, sizeof( @@prefix_pcb ) );
	pcb.sym = -1;
	pcb.tos = pcb.stack;
	pcb.vtos = pcb.vstack;
	pcb.line = 1;

	*pcb.stack = 0;
	memset( &amp;pcb.test, 0, sizeof( @@prefix_vtype ) );
	memset( pcb.vstack, 0, 1024 * sizeof( @@prefix_vtype ) );

	while( 1 )
	{
		@@prefix_get_sym( &pcb );

		if( !@@prefix_get_act_tab( &pcb ) )
		{
			/*
				Parse error
			*/
			
#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: !!!PARSE ERROR!!!\n"
					"%s: error recovery: current token %d (%s)\n",
						PARSERFILE, PARSERFILE, pcb.sym,
							@@prefix_symbol_names[ pcb.sym ] );
			fprintf( @@prefix_dbg,
					"%s: error recovery: expecting ", PARSERFILE );
					
			for( i = 1; i &lt; @@prefix_act[ *( pcb.tos ) ][0] * 3; i += 3 )
			{
				fprintf( @@prefix_dbg, "%d (%s)%s",
					@@prefix_act[ *( pcb.tos ) ][i],
					@@prefix_symbol_names[ @@prefix_act[ *( pcb.tos ) ][i] ],
					( i == @@prefix_act[ *( pcb.tos ) ][0] * 3 - 3 ) ?
							"\n" : ", " );
			}
			
			fprintf( @@prefix_dbg, "\n%s: error recovery: error_delay is %d, %s\n",
						PARSERFILE, pcb.error_delay,
						( pcb.error_delay ? "error recovery runs silently" :
							"error is reported before its recover!" ) );
#endif

			if( !pcb.error_delay )
			{
				UNICC_PARSE_ERROR( &( pcb ) );
				pcb.error_count++;
			}

#if @@error &lt; 0
#if UNICC_DEBUG
			fprintf( @@prefix_dbg,
				"%s: error recovery: No error resync token used, "
					"exiting parser.\n", PARSERFILE );
#endif
			/* No error token defined? Then exit here! */
			return 1;
#else

#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: error recovery: "
				"trying to recover...\n", PARSERFILE );
#if UNICC_STACKDEBUG
			@@prefix_dbg_stack( @@prefix_dbg, pcb.stack, pcb.tos,
				pcb.vstack, pcb.vtos );
#endif
#endif
			/* Save current sym, try to shift on error resync */
			old_sym = pcb.sym;
			pcb.sym = @@error;

			while( pcb.tos &gt;= pcb.stack )
			{
#if UNICC_DEBUG
				fprintf( @@prefix_dbg, "%s: error recovery: trying "
						"to shift error resync token...\n",
							PARSERFILE );
#if UNICC_STACKDEBUG
				@@prefix_dbg_stack( @@prefix_dbg, pcb.stack, pcb.tos,
					pcb.vstack, pcb.vtos );
#endif
#endif
				if( @@prefix_get_act_tab( &amp;pcb ) )
				{
					/* Shift */
					if( pcb.act &amp; 2 )
					{
						pcb.tos++;
						pcb.vtos++;
						
						*( pcb.tos ) = pcb.idx;
#if UNICC_DEBUG
						fprintf( @@prefix_dbg, "%s: error recovery: succeeded!\n",
									PARSERFILE );
#endif
						
						break;
					}
				}
				
				if( *( pcb.tos ) == pcb.idx )
					break;

#if UNICC_DEBUG
				fprintf( @@prefix_dbg, "%s: error recovery: failed!\n",
							PARSERFILE );
#endif
					
				pcb.tos--;
				pcb.vtos--;
			}
			
			pcb.sym = old_sym; /* Restore old sym */

			if( *( pcb.tos ) == pcb.idx )
			{
#if UNICC_DEBUG
				fprintf( @@prefix_dbg, "%s: error recovery: resync token found, "
					"trying to re-synchronize...\n", PARSERFILE );
#if UNICC_STACKDEBUG
				@@prefix_dbg_stack( @@prefix_dbg, pcb.stack, pcb.tos,
					pcb.vstack, pcb.vtos );
#endif
				fprintf( @@prefix_dbg, "%s: error recovery: resync begins with "
					"token %d (%s)\n",
						PARSERFILE, pcb.sym, @@prefix_symbol_names[ pcb.sym ] );
#endif
				while( pcb.sym != @@eof )
				{
#if UNICC_DEBUG
					fprintf( @@prefix_dbg, "%s: error recovery: "
						"trying to shift on %d (%s) in state %d\n",
							PARSERFILE, pcb.sym, @@prefix_symbol_names[ pcb.sym ],
								*( pcb.tos ) );
#endif
					if( @@prefix_get_act_tab( &amp;pcb ) )
					{

#if UNICC_DEBUG
						fprintf( @@prefix_dbg, "%s: error recovery: "
							"%d %d %d\n", PARSERFILE, *( pcb.tos ), pcb.act, pcb.idx );
#endif
						if( pcb.act &amp; 2 )
							break;

						/* Reduce */
						while( pcb.act &amp; 1 )
						{
							pcb.tos -= @@prefix_prod_lengths[ pcb.idx ];
							pcb.vtos -= @@prefix_prod_lengths[ pcb.idx ];
				
							if( pcb.idx == @@goal-production )
								break;
				
							@@prefix_get_go_tab( &amp;pcb, @@prefix_prod_lhs[ pcb.idx ] );
							
							*(++pcb.tos) = ( pcb.act &amp; 1 ) ? 0 : pcb.idx;
							++pcb.vtos;
						}
					}

#if UNICC_DEBUG
					fprintf( @@prefix_dbg, "%s: error recovery: "
						"skipping\n", PARSERFILE );
#endif
					UNICC_SRC_MOVE( pcb.len );
					@@prefix_clear_input( &amp;pcb );
					
					pcb.len = 0;
					pcb.sym = -1;
					while( !@@prefix_get_sym( &pcb ) )
					{
						/* Skip one character */
						pcb.len = 1;

						@@prefix_clear_input( &amp;pcb );
					}
					
					#if UNICC_DEBUG
					fprintf( @@prefix_dbg, "%s: error recovery: "
						"new token %d (%s)\n", PARSERFILE, pcb.sym, 
							@@prefix_symbol_names[ pcb.sym ] );
					#endif
				}
				
			}
						
			/* If this is the end-of-file, then stop parsing! */
			if( pcb.sym == @@eof )
			{
#if UNICC_DEBUG
				fprintf( @@prefix_dbg, "%s: error recovery: end-of-file "
					"token found, there is nothing to recover anymore!\n",
						PARSERFILE );
#endif
				break;
			}
			
			/* If there is no transition possible here, than exit */
			if( pcb.tos &lt; pcb.stack || !@@prefix_get_act_tab( &amp;pcb ) )
			{
#if UNICC_DEBUG
				fprintf( @@prefix_dbg, "%s: error recovery: No transitions "
					"possible, can't recover!\n", PARSERFILE );
#endif
				break;
			}
			
#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: error recovery: that's it, "
						"error has been recovered!\n", PARSERFILE );	
#endif

			pcb.error_delay = 3;
#endif
		}


#if UNICC_DEBUG
		fprintf( @@prefix_dbg,
			"%s: sym = %d (%s) [len = %d] *tos = %d act = %s idx = %d\n",
				PARSERFILE, pcb.sym, @@prefix_symbol_names[ pcb.sym ], pcb.len,
					*pcb.tos, ( ( pcb.act == 3 ) ? "shift/reduce" :
								( pcb.act &amp; 2 ) ? "shift" : "reduce" ),
									pcb.idx );
#if UNICC_STACKDEBUG
		@@prefix_dbg_stack( @@prefix_dbg, pcb.stack, pcb.tos, pcb.vstack, pcb.vtos );
#endif
#endif

		/* Shift */
		if( pcb.act &amp; 2 )
		{
#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: &gt;&gt; shifting terminal %d (%s)\n",
			PARSERFILE, pcb.sym, @@prefix_symbol_names[ pcb.sym ] );
#endif

			pcb.tos++;
			pcb.vtos++;

			*( pcb.tos ) = ( pcb.act &amp; 1 ) ? 0 : pcb.idx;

			/* Execute scanner actions, if existing */
			switch( pcb.sym )
			{
				@@scan_actions

				default:
					@@top-value = @@prefix_get_input( &amp;pcb, 0 );
					break;
			}
			
			/* Perform the shift on input */
			UNICC_SRC_MOVE( pcb.len );
			@@prefix_clear_input( &amp;pcb );
			
			if( pcb.error_delay )
				pcb.error_delay--;
		}

		/* Reduce */
		while( pcb.act &amp; 1 )
		{
#if UNICC_DEBUG			
			fprintf( @@prefix_dbg, "%s: &lt;&lt; reducing by production %d (%s)\n",
				PARSERFILE, pcb.idx, @@prefix_productions[ pcb.idx ] );
#endif
			memset( &amp;( pcb.ret ), 0, sizeof( @@prefix_vtype ) );

			switch( pcb.idx )
			{
@@actions
			}

			pcb.tos -= @@prefix_prod_lengths[ pcb.idx ];
			pcb.vtos -= @@prefix_prod_lengths[ pcb.idx ];

			if( pcb.idx == @@goal-production )
			{
				UNICC_SRC_MOVE( pcb.len );
				@@prefix_clear_input( &amp;pcb );

				#if UNICC_DEBUG
				fprintf( stderr, "%s: Goal symbol reduced, exiting parser\n\n",
						PARSERFILE );
				#endif
				
				break;
			}

			#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: after reduction, shifting nonterminal %d (%s)\n",
					PARSERFILE, @@prefix_prod_lhs[ pcb.idx ],
						@@prefix_symbol_names[ @@prefix_prod_lhs[ pcb.idx ] ] );
			#endif

			@@prefix_get_go_tab( &amp;pcb, @@prefix_prod_lhs[ pcb.idx ] );
			
			*(++pcb.tos) = ( pcb.act &amp; 1 ) ? 0 : pcb.idx;
			memcpy( ++pcb.vtos, &amp;( pcb.ret ), sizeof( @@prefix_vtype ) );
		}
		
		if( pcb.act &amp; 1 &amp;&amp; pcb.idx == @@goal-production )
			break;
	}

	#if UNICC_DEBUG
	fprintf( @@prefix_dbg, "%s: parse completed with %d errors\n",
		PARSERFILE, pcb.error_count );
	#endif
	
	if( pcb.buf )
		free( pcb.buf );
	return pcb.error_count;
}

#if @@epilogue_len == 0
int main( int argc, char** argv )
{
	char	s[ 24576+1 ];
	char	l[ 24576+1 ] ;
	short 	first;
	
	if( @@name_len &gt; 0 && @@version_len &gt; 0 )
		printf( "@@name v@@version\n" );
	
	if( @@copyright_len &gt; 0 )
		printf( "@@copyright\n\n" );
		
	printf( "UniCC LALR(1) Parser Generator :: Standard Parser Template for C programming language\n"
			"Copyright (C) 2008, 2009 by Phorward Software Technologies, Jan Max Meyer\n---\n" );
	
	do
	{
		first = 0;
		*s = '\0';
		
		printf( "\nok\n" );
#if 0 /* OLD SRC */
		do
		{
			printf( "@@name>" );
			fgets( l, sizeof( l ), stdin );
		
			if( *l == '\n' )
			{
				if( first )
					break;
				else
					first = 1;
			}
			else
				strcat( s, l );
		}
		while( 1 );
		
		//s[ strlen( s ) - 1 ] = '\0';
		
		if( !( *s ) )
			break;
#endif

		printf( "@@name>" );
		@@prefix_parse();

	}
	while( 1 );
	
	return 0;
}
#else
@@epilogue
#endif
</driver>
</generator>
