/* -MODULE----------------------------------------------------------------------
UniCC LALR(1) Parser Generator 
Copyright (C) 2006-2009 by Phorward Software Technologies, Jan Max Meyer
http://unicc.phorward-software.com/ ++ unicc<<AT>>phorward-software<<DOT>>com

File:	p_parse.par/p_parse.c
Author:	Jan Max Meyer
Usage:	Grammar definition parser

You may use, modify and distribute this software under the terms and conditions
of the Artistic License, version 2. Please see LICENSE for more information.
----------------------------------------------------------------------------- */
#!model			context-sensitive ;

/*
 * Information directives
 */
#parser			"UniCC Grammar Definition Language";
#version		"1.2";
#description	"Parser for UniCC parser definitions";
#copyright		"Copyright (C) 2008, 2009 by Jan Max Meyer, Phorward Software Technologies";

/*
 * Prologue
 */

//Begin of Prologue ------------------------------------------------------------
#prologue		[*

/*
 * Includes
 */
#include "p_global.h"
#include "p_proto.h"
#include "p_error.h"

/*
 * Global variables
 */
 
struct @@prefix_nfa
{
	NFA*	start;
	NFA*	end;
};

struct @@prefix_rhs_item
{
	SYMBOL*	sym;
	uchar*	ident;
};

#ifndef MALLOC_STEP
#define MALLOC_STEP 255
#endif

PARSER*	parser			= (PARSER*)NULL;

static int		directive_level	= 0; /* Directive level */
static int		prec_cnt		= 1; /* Precedence level */
static int		line			= 1; /* Line within source file */
static int 		auto_regex		= 0; /* Nameless Regex counter */
static int		last_code_begin;	 /* Last code begin */
static BOOLEAN	footer_code		= FALSE; /* Flag for footer code recognition */
static int		embedded_count	= 0;
static PROD*	current_prod	= (PROD*)NULL;

extern int	error_count;

uchar*	strbuf			= (uchar*)NULL;
LIST*	nfa_m			= (LIST*)NULL;

/*
 * Functions
 */

/* Append character to current string */
static void strbuf_append( uchar ch )
{
	int len;
	len = strbuf ? (int)strlen( strbuf ) : 0;

	if( !strbuf )
		strbuf = (uchar*)p_malloc( ( MALLOC_STEP + 2 ) * sizeof( uchar ) );
	else if( len % MALLOC_STEP == 0 )
		strbuf = (uchar*)p_realloc( (uchar*)strbuf, ( len + MALLOC_STEP + 2 ) * sizeof( uchar ) );

	strbuf[len] = ch;
	strbuf[len+1] = '\0';
	strbuf[len+2] = '\0';
}

static void strbuf_prefix( uchar ch )
{
	int len;
	uchar* tmp;
	len = strbuf ? (int)strlen( strbuf ) : 0;

	if( !strbuf )
		strbuf = (uchar*)p_malloc( ( MALLOC_STEP + 2 ) * sizeof( uchar ) );
	else if( len % MALLOC_STEP == 0 )
		strbuf = (uchar*)p_realloc( (uchar*)strbuf, ( len + MALLOC_STEP + 2 ) * sizeof( uchar ) );

	tmp = p_strdup( strbuf );
	sprintf( strbuf, "%c%s%c", ch, tmp, '\0' );
	p_free( tmp );
}

/* Create a new string */
static void reset_strbuf( void )
{
	if( strbuf )
	{
		*strbuf = '\0';
		*(strbuf+1) = '\0';
	}
}


/* Set precedence and associativiy */
static void set_assoc_and_prec( LIST* symbols, int assoc )
{
	LIST* l;
	SYMBOL* sym;

	for( l = symbols; l; l = l->next )
	{
		sym = l->pptr;
		sym->prec = prec_cnt;
		sym->assoc = assoc;
	}

	list_free( symbols );
	prec_cnt++;
}

static void set_nfa_to_symbols( SYMBOL* s, NFA* start, NFA* end )
{
	NFA*	nstart;

	nstart = re_create_nfa( &( s->nfa_def ) );
	nstart->next = start;
	end->accept = s->id;

	s->nfa_def = list_union( s->nfa_def, nfa_m );
	nfa_m = list_free( nfa_m );

	s->keyword = TRUE;
}

void make_semantic_rhs( PROD* p )
{
	int		i;
	LIST*	l		= (LIST*)NULL;
	uchar*	dup;
	
	if( current_prod && current_prod->rhs )
	{
		p->sem_rhs = list_dup( current_prod->rhs );
		for( l = p->sem_rhs; list_next( l ); l = list_next( l ) )
			;
			
		l->next = list_dup( p->rhs );
	}
	else
		p->sem_rhs = list_dup( p->rhs );

	for( i = 0; i < 2; i++ )
	{
		if( !i )
		{
			if( current_prod )
				l = current_prod->rhs_idents;
			else
				l = (LIST*)NULL;
		}
		else
			l = p->rhs_idents;

		for( ; l; l = list_next( l ) )
		{
			dup = (uchar*)list_access( l );
			if( dup )
			{
				if( !( dup = p_strdup( dup ) ) )
					OUT_OF_MEMORY;
			}
				
			p->sem_rhs_idents = list_push(
				p->sem_rhs_idents, (void*)dup );
		}
	}
}


*];
//End of Prologue --------------------------------------------------------------

/*
 * Parser configuration
 */

#end of input		'\0';
#language			"C";
#whitespaces 		whitespace;
#lexeme				terminal identifier modifier code ccl_string kw type;
#default action		[* @@ = @1; *];

/*
 * Grammar
 */

grammar_spec$		->	fixed_directives segments
					;

segments			->	segments segment
					|
					;

fixed_directives	->	fixed_directives "#!" fixed_directive ';'
					|
					;

fixed_directive		-> "model"				model_type
					| "character universe"	integer				[*	int universe = atoi( strbuf );

																	if( universe > 0 )
																		parser->p_universe = universe;
																	else
																		p_error( ERR_INVALID_CHAR_UNIVERSE,
																			ERRSTYLE_FATAL | ERRSTYLE_FILEINFO,
																				parser->filename, line );
																*]
					;

model_type			->	"context-sensitive"						[*	parser->p_model = MODEL_CONTEXT_SENSITIVE;	*]
					| "context-free"							[*	parser->p_model = MODEL_CONTEXT_FREE;		*]
					;

segment				->	code
					| definition ';'
					| unfixed_directive ';'
					;

unfixed_directive	->	'#' directive_parms
					;

directive_parms		-> "whitespaces" 	symbol_list				[*	LIST* l;
																	SYMBOL* s;

																	for( l = @2; l; l = l->next )
																	{
																		s = l->pptr;

																		/* Do not allow nonterminal definitions here
																			in conext-free model */
																		if( s->type == SYM_NON_TERMINAL &&
																			parser->p_model !=
																				MODEL_CONTEXT_SENSITIVE )
																		{
																			p_error( ERR_NONTERM_WS_NOT_ALLOWED,
																				ERRSTYLE_FATAL | ERRSTYLE_FILEINFO,
																						parser->filename, line,
																							s->name );
																		}
																		else
																			s->whitespace = TRUE;
																	}

																	list_free( @2 );
																*]
					| "lexeme"			symbol_list				[*	LIST* l;
																	SYMBOL* s;


																	/* Ouput a warning, if this definition
																		is effectless */
																	if( parser->p_model != MODEL_CONTEXT_SENSITIVE )
																	{
																		p_error( ERR_NO_EFFECT_IN_MODEL,
																			ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
																				parser->filename, line, "lexeme" );
																	}
																	else
																	{
																		for( l = @2; l; l = l->next )
																		{
																			s = l->pptr;
																			s->lexem = TRUE;
																		}
																	}

																	list_free( @2 );
																*]
					| "fixate" 			symbol_list				[*	LIST* l;
																	SYMBOL* s;

																	/* Ouput a warning, if this definition
																		is effectless */
																	if( parser->p_model != MODEL_CONTEXT_SENSITIVE )
																	{
																		p_error( ERR_NO_EFFECT_IN_MODEL,
																			ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
																				parser->filename, line, "fixate" );
																	}
																	else
																	{
																		for( l = @2; l; l = l->next )
																		{
																			s = l->pptr;
																			s->fixated = TRUE;
																		}
																	}

																	list_free( @2 );

																*]
					| "left"			symbol_list				[*	set_assoc_and_prec( @2, ASSOC_LEFT ); 	*]
					| "right"			symbol_list				[*	set_assoc_and_prec( @2, ASSOC_RIGHT ); 	*]
					| "nonassoc"		symbol_list				[*	set_assoc_and_prec( @2, ASSOC_NOASSOC ); *]
					| "parser"			string					[*	if( !( parser->p_name ) )
																			parser->p_name = p_strdup( strbuf );	*]
					| "description"		string					[*	if( !( parser->p_desc ) )
																			parser->p_desc = p_strdup( strbuf );	*]
					| "copyright"		string					[*	if( !( parser->p_copyright ) )
																			parser->p_copyright = p_strdup( strbuf ); *]
					| "version"			string					[*	if( !( parser->p_version ) )
																		parser->p_version= p_strdup( strbuf );	*]
					| "prefix"			string					[*	if( !( parser->p_prefix ) )
																		parser->p_prefix = p_strdup( strbuf );	*]
					| "language"		string					[*	if( !( parser->p_language ) )
																			parser->p_language = p_strdup( strbuf ); *]
					| "default action"	code					[*	if( !( parser->p_def_action ) )
																			parser->p_def_action = p_strdup( strbuf );
																*]
					| "default epsilon action"		code		[*	if( !( parser->p_def_action_e ) )
																			parser->p_def_action_e = p_strdup( strbuf ); *]
					| "end of input"	terminal				[*	parser->end_of_input = @2;	*]
					| "invalid keyword suffix"	ccl				[*	/* Ouput a warning, if this definition
																		is effectless */
																	if( parser->p_model != MODEL_CONTEXT_SENSITIVE )
																	{
																		p_error( ERR_NO_EFFECT_IN_MODEL,
																			ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
																				parser->filename, line,
																					"invalid keyword suffix" );
																	}
																	else
																	{
																		parser->p_invalid_suf = p_strdup( strbuf );
																		parser->p_neg_inv_suf = @2;
																	}
																*]
					| "lexem separation" boolean				[*	/* Ouput a warning, if this definition
																		is effectless */
																	if( parser->p_model != MODEL_CONTEXT_SENSITIVE )
																	{
																		p_error( ERR_NO_EFFECT_IN_MODEL,
																			ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
																				parser->filename, line,
																					"lexem separation" );
																	}
																	else
																		parser->p_lexem_sep = !@2;
																*]
					| "case insensitive keywords"	boolean		[*	parser->p_cis_keywords = !@2;	*]
					| "prologue"					code		[*	parser->p_header = p_str_append(
																			parser->p_header, strbuf, FALSE );	*]
					| "epilogue"					code		[*	parser->p_footer = p_str_append(
																			parser->p_footer, strbuf, FALSE );	*]
					;

boolean<BOOLEAN>	->	"on"									[*	@@ = FALSE; 	*]
					| 	"off"									[*	@@ = TRUE; 		*]
					|											[*	@@ = FALSE; 	*]
					;

symbol_list<LIST*>	->	symbol_list sym							[*	@@ = list_push( @1, (void*)@2 );			*]
					| sym										[*	@@ = list_push( (LIST*)NULL, (void*)@1 );	*]
					;

definition			->	lhs goal_mark type "->" productions		[*
																	LIST* l;
																	PROD* p;

																	@1->productions = @5;
																	
																	if( @2 )
																	{
																		if( parser->goal )
																		{
																			p_error( ERR_MULTIPLE_GOAL_DEF,
																				ERRSTYLE_FATAL,
																					parser->goal->name );
																		}
																		else
																		{
																			parser->goal = @1;
																			parser->goal->used = TRUE;
																		}
																	}

																	/* Link productions with this left-hand side */
																	for( l = @5; l; l = l->next )
																	{
																		p = l->pptr;
																		p->lhs = @1;
																	}

																	/* Value type */
																	if( @3 )
																	{
																		VTYPE*	vt;

																		vt = p_create_vtype( parser,
																				(uchar*)@3 );
																		@1->vtype = vt;

																		p_free( @3 );
																	}
																*]
					| '@' identifier_copy type regex code_opt	[*	SYMBOL* s;
																	s = p_get_symbol( parser,
																			@2, SYM_REGEX_TERMINAL, TRUE );
																	s->defined = TRUE;

																	p_free( @2 );

																	set_nfa_to_symbols( s, @4.start, @4.end );

																	/* Attach code */
																	if( @5 )
																	{
																		s->code = strbuf;
																		s->code_at = last_code_begin;
																		strbuf = (uchar*)NULL;
																	}

																	/* Value type */
																	if( @3 )
																	{
																		VTYPE*	vt;

																		vt = p_create_vtype( parser, @3 );
																		s->vtype = vt;
																		p_free( @3 );
																	}

																	/* re_dbg_print_nfa( s->nfa_def,
																		parser->p_universe ); */
																*]
					;

lhs<SYMBOL*>		->	identifier								[*	@@ = p_get_symbol( parser,
																			strbuf, SYM_NON_TERMINAL, TRUE );
																	@@->defined = TRUE;
																*]
					;

goal_mark<BOOLEAN>	-> '$'										[*	@@ = TRUE; *]
					|											[*	@@ = FALSE; *]
					;

productions<LIST*>	->	productions '|' production				[*	@@ = list_push( @1, @3 ); 			*]
					| production								[*	@@ = list_push( (LIST*)NULL, @1 );	*]
					;
					
production<PROD*>	->	rhs_opt line_number code_opt			[*
																	@1->code_at = @2;
																	if( @3 )
																	{
																		@1->code = p_strdup( @3 );
																		@1->code_at = last_code_begin;
																	}

																	@@ = @1;
																	
																	current_prod = (PROD*)NULL;
																*]
					;

rhs_opt<PROD*>		->	rhs

					|											[*	@@ = p_create_production( parser,
																		(SYMBOL*)NULL );
																*]
					;
					

rhs<PROD*>			->	rhs symbol access_name					[*	p_append_to_production( @1, @2,
																		( *strbuf == '\0' ? (uchar*)NULL :
																			p_strdup( strbuf ) ) );
																	@@ = @1;
																*]
					|	symbol access_name						[*	@@ = current_prod =
																		p_create_production( parser,
																			(SYMBOL*)NULL );

																	p_append_to_production( @@, @1,
																		( *strbuf == '\0' ? (uchar*)NULL :
																			p_strdup( strbuf ) ) );
																*]
					;

symbol<SYMBOL*>		->	sym modifier							[*
																	switch( @2 )
																	{
																		case '*':
																			@@ = p_kleene_closure( parser, @1 );
																			break;
																		case '+':
																			@@ = p_positive_closure( parser, @1 );
																			break;
																		case '?':
																			@@ = p_optional_closure( parser, @1 );
																			break;
																		default:
																			@@ = @1;
																			break;
																	}
																*]
					|	'#' "error"								[*	@@ = p_get_symbol( parser,
																			P_ERROR_RESYNC, SYM_ERROR_RESYNC,
																				TRUE );
																	@@->used = TRUE;
																	@@->defined = TRUE;
																*]
					;

sym<SYMBOL*>		-> terminal

					| identifier								[*	@@ = p_get_symbol( parser,
																			strbuf, SYM_NON_TERMINAL, TRUE );
																	@@->used = TRUE;
																*]
					| '%' type line_number code		 			[*	uchar	temp_nonterm[ ONE_LINE + 1 ];
																	PROD*	prod;
																	
																	sprintf( temp_nonterm, P_EMBEDDED,
																			embedded_count++ );
																	
																	@@ = p_get_symbol( parser,
																			temp_nonterm, SYM_NON_TERMINAL,
																				TRUE );
																	@@->defined = TRUE;
																	@@->used = TRUE;
																	@@->generated = TRUE;

																	/* Value type */
																	if( @2 )
																	{
																		VTYPE*	vt;

																		vt = p_create_vtype( parser,
																				(uchar*)@2 );
																		@@->vtype = vt;

																		p_free( @2 );
																	}
																				
																	prod = p_create_production( parser, @@ );
																	prod->code = p_strdup( strbuf );
																	prod->code_at = @3;
																	
																	make_semantic_rhs( prod );
																	
																	@@->productions = list_push( (LIST*)NULL, prod );
																*]
					| '%' type stack_cur_prod
							'(' productions ')'					[*
																	uchar	temp_nonterm[ ONE_LINE + 1 ];
																	PROD*	prod;
																	LIST*	l;
																	
																	sprintf( temp_nonterm, P_EMBEDDED,
																			embedded_count++ );
																	
																	@@ = p_get_symbol( parser,
																			temp_nonterm, SYM_NON_TERMINAL,
																				TRUE );
																	@@->defined = TRUE;
																	@@->used = TRUE;
																	@@->generated = TRUE;

																	/* Value type */
																	if( @2 )
																	{
																		VTYPE*	vt;

																		vt = p_create_vtype( parser,
																				(uchar*)@2 );
																		@@->vtype = vt;

																		p_free( @2 );
																	}
																	
																	/* Associate the productions */
																	@@->productions = @5;
																	current_prod = @3;

																	/* Link productions with this left-hand side */
																	for( l = @5; l; l = list_next( l ) )
																	{
																		prod = (PROD*)list_access( l );
																		prod->lhs = @@ ;
																		
																		make_semantic_rhs( prod );
																	}
																*]
					;
					
stack_cur_prod<PROD*>
					->											[*
																	@@ = current_prod;
																	current_prod = (PROD*)NULL;
																*]
					;

terminal<SYMBOL*>	->	ccl										[*	char* name = strbuf;

																	if( @1 )
																		name = p_negate_ccl( parser, name );

																	@@ = p_get_symbol( parser,
																			name, SYM_CCL_TERMINAL, TRUE );
																			
																	@@->defined = TRUE;
																	@@->used = TRUE;

																	if( @1 )
																		p_free( name );
																*]
					| kw										[*	@@ = p_get_symbol( parser,
																			strbuf, SYM_KW_TERMINAL, TRUE );
																	@@->keyword = TRUE;

																	@@->defined = TRUE;
																	@@->used = TRUE;
																*]
					| integer									[*	@@ = p_get_symbol( parser,
																			strbuf, SYM_EXTERN_TERMINAL, TRUE );

																	@@->defined = TRUE;
																	@@->used = TRUE;
																*]
					| '@' identifier							[*	@@ = p_get_symbol( parser,
																			strbuf, SYM_REGEX_TERMINAL, TRUE );

																	@@->defined = TRUE;
																	@@->used = TRUE;
																*]
					;

modifier<int>		->	'*'										[*	@@ = (int)'*';	*]
					| 	'+'										[*	@@ = (int)'+'; 	*]
					|	'?'										[*	@@ = (int)'?';	*]
					|											[*	@@ = 0; 		*]
					;

access_name			->	':' identifier
					|											[*	reset_strbuf(); *]
					;

/* Regular Expression parser and NFA generator */
regex<struct @@prefix_nfa>			->	re_alt
					;

re_alt<struct @@prefix_nfa>			->	re_alt '|' re_expr		[*	@@.start = re_create_nfa( &nfa_m );
																	@@.end = re_create_nfa( &nfa_m );

																	@@.start->next = @1.start;
																	@@.start->next2 = @3.start;

																	@1.end->next = @@.end;
																	@3.end->next = @@.end;
																*]
					| re_expr
					;

re_expr<struct @@prefix_nfa>		->	re_expr re_modifier		[*	@@.start = @1.start;
																	@@.end = @2.end;
																	@1.end->next = @2.start;
																*]
					| re_modifier
					;

re_modifier<struct @@prefix_nfa>	->	re_factor '*'			[*	@@.start = re_create_nfa( &nfa_m );
																	@@.end = re_create_nfa( &nfa_m );

																	@@.start->next = @1.start;
																	@@.start->next2 = @@.end;
																	@@.end->next2 = @@.start;

																	@1.end->next = @@.end;
																*]
					| re_factor '+'								[*	@@.start = @1.start;
																	@@.end = @1.end;
																	@@.end->next2 = @@.start;
																*]
					| re_factor '?'								[*	@@.start = re_create_nfa( &nfa_m );

																	@@.start->next = @1.start;
																	@@.start->next2 = @1.end;
																	@@.end = @1.end;
																*]
					| re_factor
				;

re_factor<struct @@prefix_nfa>		->	ccl						[*	uchar*	tmp;
																	@@.start = re_create_nfa( &nfa_m );
																	@@.end = @@.start->next = re_create_nfa( &nfa_m );

																	@@.start->edge = CCL;
																	if( @1 )
																	{
																		tmp = p_negate_ccl( parser, strbuf );

																		@@.start->cclass =
																			p_ccl_to_map( parser, tmp );

																		p_free( tmp );
																	}
																	else
																		@@.start->cclass =
																			p_ccl_to_map( parser, strbuf );
																*]
				| kw											[*	uchar*	ch;

																	if( *strbuf )
																	{
																		@@.end = @@.start = re_create_nfa(
																			&nfa_m );

																		for( ch = strbuf; *ch; ch++ )
																		{
																			@@.end->edge = *ch;
																			@@.end = @@.end->next
																				= re_create_nfa( &nfa_m );
																		}
																	}
																*]
				| '.'											[*	int i;

																	@@.start = re_create_nfa(
																		&( nfa_m ) );
																	@@.end = @@.start->next
																		= re_create_nfa(
																			&( nfa_m ) );

																	@@.start->edge = CCL;
																	@@.start->cclass =
																		bitset_create( parser->p_universe );

																	for( i = 0; i < parser->p_universe; i++ )
																		bitset_set( @@.start->cclass, i, 1 );
																*]
				| '(' regex ')'									[*	@@.start = @2.start;
																	@@.end = @2.end;
																*]
				;

/* General parsing objects */
string			->	ccl_string | kw;

ccl<BOOLEAN>	->	ccl_string									[*	@@ = FALSE; *]
				| '!' ccl_string								[*	@@ = TRUE; *]
				;

ccl_string		->	'\'' ccl_str '\'';

ccl_str			->	ccl_str ccl_char
				|												[*	reset_strbuf(); *]
				;

ccl_char		->	!'\\\''										[* strbuf_append( @1 ); *]
				| '\\' !'\0'									[* strbuf_append( (uchar)'\\' );
																   strbuf_append( @2 ); 	  *]
				;

kw				->	'\"' kw_str '\"';

kw_str			->	kw_str !'\"'								[* 	strbuf_append( @2 ); *]
				|												[*	reset_strbuf(); *]
				;

type<uchar*>	->	'<' type_str '>'							[*	@@ = p_strdup( strbuf );		*]
				|												[*	@@ = (uchar*)NULL; 				*]
				;

type_str		->	type_str !'>'								[* 	strbuf_append( @2 );		 	*]
				|												[* 	reset_strbuf(); 				*]
				;


identifier_copy<uchar*>
				->	identifier									[*	@@ = strbuf;
																	strbuf = (uchar*)NULL;
																*]
				;

identifier		->	identifier_start identifier_follow
				;

identifier_start
				->	'A-Za-z_'									[* 	reset_strbuf();
																	strbuf_append( @1 );
																*]
				;

identifier_follow
				-> identifier_follow 'A-Za-z0-9_'				[*	strbuf_append( @2 ); 		*]
				|
				;

integer			->	integer '0-9'								[*	strbuf_append( @2 ); 		*]
				| '0-9'											[* 	reset_strbuf();
																	strbuf_append( @1 );
																*]
				;

code_opt<uchar*>->	code										[*	@@ = strbuf;				*]
				|												[*	reset_strbuf();
																	@@ = (uchar*)NULL;			*]
				;

code			->	code_begin inner_code_opt "*]"
				;
				
code_begin		->	"[*"										[* last_code_begin = line;		*]
				;

inner_code_opt	->	inner_code
				|												[*	reset_strbuf(); *]
				;

inner_code		->	inner_code anychar							[*	strbuf_append( @2 );		*]
				|	anychar										[*	reset_strbuf();
																	strbuf_append( @1 );
																*]
				;

whitespace		-> ' '
				| '\t'
				| "/*" comment? "*/"
				| "//" scomment? '\n'							[* line++;	*]
				| '\r'
				| '\n'											[* line++; 	*]
				;

comment			->	comment anychar
				|	anychar
				;
				
anychar			->	!'\0'										[*	if( @1 == '\n' )
																		line++;
																	@@ = @1;
																*]
				;

scomment		->	scomment !'\n'
				| !'\n'
				;

line_number		->												[* @@ = line;					*]
				;

#epilogue

[*

int p_parse( PARSER* p, uchar* src )
{
	char* s,
		* sp;
	int err = -1;

	line = 1;
	auto_regex = 0;
	prec_cnt = 1;
	directive_level = 0;
	embedded_count = 0;

	if( p && src )
	{
		err = 0;

		parser = p;
		strbuf_append( '\0' );

		s = sp = src;

		#if PDEBUG
		printf( "<<< %s >>>\n", s );
		#endif
		err = @@prefix_parse( s );

		p_free( strbuf );
	}

	return err + error_count;
}

*];
