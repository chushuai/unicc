/*-PARSER----------------------------------------------------------------------
UniCC LALR(1) Parser Generator 
Copyright (C) 2006-2011 by Phorward Software Technologies, Jan Max Meyer
http://unicc.phorward-software.com/ ++ unicc<<AT>>phorward-software<<DOT>>com

File:	p_parse.par
Author:	Jan Max Meyer
Usage:	Grammar definition parser

You may use, modify and distribute this software under the terms and conditions
of the Artistic License, version 2. Please see LICENSE for more information.
---------------------------------------------------------------------------- */

#!mode			sensitive ;
#!language		"C";

/*
 * IMPORTANT NOTIFICATION ON THIS PARSER
 * -------------------------------------
 * This module underlies to a special coding convention: Because UniCC is boot-
 * strapped from an older parser that is compiled using min_lalr1 (p_parse.syn),
 * the use of some features is prohibited because they are only featured by the
 * parser defined in this module. The old parser is not tended anymore with new
 * features.
 *
 * So please consider the following rules, to avoid incompatibilities:
 * 1. Don't use #pcb or something, #option-features are not supported
 * 2. Don't use embedded productions - insert a new nonterminal for this
 * 3. Don't set precedence to productions
 * 4. Don't use long-string identifiers for symbols
 *
 * Some other rules may be inserted here in future versions.
 */

/*
 * Information directives
 */
#parser			"UniCC Grammar Definition Language";
#version		"1.5";
#description	"Parser for UniCC parser definitions";
#copyright		"Copyright (C) 2008-2011 by Jan Max Meyer, Phorward Software Technologies";

/*
 * Parser configuration
 */
#end of input		'\0';
#whitespaces 		whitespace;
#lexeme				terminal identifier modifier code ccl_string kw type;
#lexeme separation	on;
#default action			[* @@ = @1; *];
#default epsilon action	[* @@ = 0; *];

/*
 * Prologue
 */

//Begin of Prologue ------------------------------------------------------------
#prologue		[*

/*
 * Includes
 */
#include "p_global.h"
#include "p_proto.h"
#include "p_error.h"

/*
 * Global variables
 */
 
struct @@prefix_nfa
{
	pregex_nfa_st*	start;
	pregex_nfa_st*	end;
};

struct @@prefix_rhs_item
{
	SYMBOL*	sym;
	uchar*	ident;
};

#ifndef MALLOC_STEP
#define MALLOC_STEP 255
#endif

#define UNICC_GETINPUT				getinput()
#define UNICC_PARSE_ERROR( pcb )	p_parse_error( pcb )


PARSER*	parser			= (PARSER*)NULL;

static uchar*	src_ptr;
static int		directive_level	= 0; /* Directive level */
static int		prec_cnt		= 1; /* Precedence level */
static int		line			= 1; /* Line within source file */
static int 		auto_regex		= 0; /* Nameless Regex counter */
static int		last_code_begin;	 /* Last code begin */
static int		embedded_count	= 0;
static PROD*	current_prod	= (PROD*)NULL;
static SYMBOL*	current_sym		= (SYMBOL*)NULL;

extern int	error_count;

uchar*		strbuf			= (uchar*)NULL;
uchar*		regex			= (uchar*)NULL;
pregex_nfa	nfa_m;

/*
 * Functions
 */

/* DEBUG */
static int getinput( void )
{
	int ch;
	
	/*
		IMPORTANT:
		We have to watch out for the zero-terminator;
		The parser will in some cases continue fetching
		new characters with UNICC_GETINPUT. If we read
		over the zero terminator, the parser's behavior
		will be undefined, so we may only increment it
		if we're not there!

		(Searching this BUG took at least 4 hours and
		one broken laptop -.- *arghh*)
	*/
	if( ( ch = *(src_ptr) ) )
		src_ptr++;

#if UNICC_DEBUG
	fprintf( stderr, "ch = %d (%c)\n", ch, (char)ch );
#endif
	return ch;
}

/* Append character to current string */
static void strbuf_append( uchar ch )
{
	int len;

	len = pstrlen( strbuf );

	if( !strbuf )
		strbuf = (uchar*)p_malloc( ( MALLOC_STEP + 2 ) * sizeof( uchar ) );
	else if( len % MALLOC_STEP == 0 )
		strbuf = (uchar*)p_realloc( (uchar*)strbuf, ( len + MALLOC_STEP + 2 )
			* sizeof( uchar ) );

	strbuf[len] = ch;
	strbuf[len+1] = '\0';
	strbuf[len+2] = '\0';
}


/* Create a new string */
static void reset_strbuf( void )
{
	if( strbuf )
	{
		*strbuf = '\0';
		*(strbuf+1) = '\0';
	}
}


/* Set precedence and associativiy */
static void set_assoc_and_prec( LIST* symbols, int assoc )
{
	LIST* l;
	SYMBOL* sym;

	for( l = symbols; l; l = l->next )
	{
		sym = l->pptr;
		sym->prec = prec_cnt;
		sym->assoc = assoc;
	}

	list_free( symbols );
	prec_cnt++;
}


static void set_nfa_to_symbols( SYMBOL* s,
	pregex_nfa_st* start, pregex_nfa_st* end )
{
	pregex_nfa_st*	nstart;
	
	if( !( nstart = pregex_nfa_create_state(
			&( s->nfa ), (uchar*)NULL, REGEX_MOD_NONE ) ) )
		OUTOFMEM;

	nstart->next = start;
	end->accept = s->id;
	
	if( !( s->nfa.states = list_union( s->nfa.states, nfa_m.states ) ) )
		OUTOFMEM;
		
	list_free( nfa_m.states );
	memset( &nfa_m, 0, sizeof( pregex_nfa ) );
}

static void make_semantic_rhs( PROD* p )
{
	int		i;
	LIST*	l		= (LIST*)NULL;
	uchar*	dup;
	
	if( current_prod && current_prod->rhs )
	{
		p->sem_rhs = list_dup( current_prod->rhs );
		for( l = p->sem_rhs; list_next( l ); l = list_next( l ) )
			;
			
		l->next = list_dup( p->rhs );
	}
	else
		p->sem_rhs = list_dup( p->rhs );

	for( i = 0; i < 2; i++ )
	{
		if( !i )
		{
			if( current_prod )
				l = current_prod->rhs_idents;
			else
				l = (LIST*)NULL;
		}
		else
			l = p->rhs_idents;

		for( ; l; l = list_next( l ) )
		{
			dup = (uchar*)list_access( l );
			if( dup )
			{
				if( !( dup = p_strdup( dup ) ) )
					OUTOFMEM;
			}
				
			p->sem_rhs_idents = list_push(
				p->sem_rhs_idents, (void*)dup );
		}
	}
}

static OPT* set_option( HASHTAB* ht, uchar* key, uchar* val, int line )
{
	HASHELEM*	he;
	OPT*		opt;

	if( !( opt = p_create_opt( ht, key, (uchar*)NULL ) ) )
		OUTOFMEM;

	opt->def = val;
	opt->line = line;

	return opt;

	/*
	if( ( he = hashtab_get( ht, key ) ) )
	{
		if( !( val = pstr_append_str(
				(uchar*)hashelem_access( he ), val, TRUE ) ) )
			OUTOFMEM;

		hashtab_update( ht, key, (void*)val );
	}
	else if( !hashtab_insert( ht, key, val ) )
		OUTOFMEM;
	*/
}


static void p_parse_error();

*];
//End of Prologue --------------------------------------------------------------

/*
 * Grammar
 */

grammar_spec$		->	fixed_directive_def* segment*
					;

fixed_directive_def	-> "#!" fixed_directive ';'
					;

fixed_directive		-> "mode"				mode_type
					|  "model"				mode_type
					| "language"		string
						[*	
							if( !( parser->p_language ) )
								parser->p_language = p_strdup( strbuf );
							else
								p_error( parser, ERR_DIRECTIVE_ALREADY_USED,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, line, 
											"!language" );
						*]

					//TODO: Must be reworked!
					| "character universe"	integer				
					
						[*	int universe = atoi( strbuf );

							if( universe > 0 )
								parser->p_universe = universe;
							else
								p_error( parser, ERR_INVALID_CHAR_UNIVERSE,
									ERRSTYLE_FATAL | ERRSTYLE_FILEINFO,
										parser->filename, line );
						*]
					;

mode_type			->	"context-sensitive"
						[*	parser->p_mode = MODE_SENSITIVE; *]
					|	"sensitive"
						[*	parser->p_mode = MODE_SENSITIVE; *]
					| "context-insensitive"
						[*	parser->p_mode = MODE_INSENSITIVE;*]
					| "insensitive"
						[*	parser->p_mode = MODE_INSENSITIVE;*]
					;

segment				->	code
					| definition ';'
					| unfixed_directive ';'
					;

unfixed_directive	->	'#' directive_parms
					/*
					| &error
						[*
							printf( "Incomplete directive\n" );
						*]
					*/
					;

@USERDEF<uchar*>	!'\0"\'/ \t\n\r!;'+ 
					[*
						@@ = (uchar*)pmalloc( ( ( @< - @> ) + 1 )
												* sizeof( uchar ) );
						psprintf( @@, "%.*s", @< - @>, @> );
					*];

userparam			->	code
					|	string
					|	boolean
						[*
							if( !@boolean )
								strbuf_append( '1' );
							else
								strbuf_append( '0' );
						*]
					|	[*	reset_strbuf(); *]
					;

directive_parms		-> "whitespaces" 	symbol_list				
						[*	LIST* l;
							SYMBOL* s;

							for( l = @2; l; l = l->next )
							{
								s = l->pptr;

								/* Do not allow nonterminal definitions here
									in conext-free model */
								if( s->type == SYM_NON_TERMINAL &&
									parser->p_mode !=
										MODE_SENSITIVE )
								{
									p_error( parser, ERR_NONTERM_WS_NOT_ALLOWED,
										ERRSTYLE_FATAL | ERRSTYLE_FILEINFO,
												parser->filename, line,
													s->name );
								}
								else
									s->whitespace = TRUE;
							}

							list_free( @2 );
						*]

					| "lexeme"			symbol_list
						[*	LIST* l;
							SYMBOL* s;


							/* Ouput a warning, if this definition
								is effectless */
							if( parser->p_mode != MODE_SENSITIVE )
							{
								p_error( parser, ERR_NO_EFFECT_IN_MODE,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, line, "lexeme" );
							}
							else
							{
								for( l = @2; l; l = l->next )
								{
									s = l->pptr;
									s->lexem = TRUE;
								}
							}

							list_free( @2 );
						*]

					| "fixate" 			symbol_list	
						[*	LIST* l;
							SYMBOL* s;

							/* Ouput a warning, if this definition
								is effectless */
							if( parser->p_mode != MODE_SENSITIVE )
							{
								p_error( parser, ERR_NO_EFFECT_IN_MODE,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, line, "fixate" );
							}
							else
							{
								for( l = @2; l; l = l->next )
								{
									s = l->pptr;
									s->fixated = TRUE;
								}
							}

							list_free( @2 );

						*]

					| "left"			symbol_list	
						[*	set_assoc_and_prec( @2, ASSOC_LEFT ); 	*]


					| "right"			symbol_list
						[*	set_assoc_and_prec( @2, ASSOC_RIGHT ); 	*]


					| "nonassoc"		symbol_list
						[*	set_assoc_and_prec( @2, ASSOC_NOASSOC ); *]

					| "parser"			string
						[*	parser->p_name = pstr_append_str( 
								parser->p_name, strbuf, FALSE );	*]

					| "description"		string		
						[*	parser->p_desc = pstr_append_str( 
								parser->p_desc, strbuf, FALSE );	*]

					| "copyright"		string
						[*	parser->p_copyright = pstr_append_str( 
								parser->p_copyright, strbuf, FALSE );	*]

					| "version"			string					
						[*	parser->p_version = pstr_append_str( 
								parser->p_version, strbuf, FALSE );	*]

					| "prefix"			string
						[*	parser->p_prefix = pstr_append_str( 
								parser->p_prefix, strbuf, FALSE );	*]

					| "default action"	code_opt
						[*	if( !( parser->p_def_action ) )
								parser->p_def_action = p_strdup( strbuf );
							else
								p_error( parser, ERR_DIRECTIVE_ALREADY_USED,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, line,
											"default epsilon action" );
						*]

					| "default epsilon action"		code_opt
						[*	if( !( parser->p_def_action_e ) )
								parser->p_def_action_e = p_strdup( strbuf );
							else
								p_error( parser, ERR_DIRECTIVE_ALREADY_USED,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, line,
											"default epsilon action" );
						*]

					| "default value type" type
						[*	if( !( parser->p_def_type ) )
								parser->p_def_type = p_create_vtype(
									parser, (uchar*)@type );
							else
								p_error( parser, ERR_DIRECTIVE_ALREADY_USED,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, line,
											"default value type" );

							p_free( @type );
						*]

					| "end of input"	terminal
						[*	
							if( !( parser->end_of_input ) )
								parser->end_of_input = @2;
							else
								p_error( parser, ERR_DIRECTIVE_ALREADY_USED,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, line,
											"end of input" );
						*]

					| "lexeme separation" boolean_opt
						[*	/* Ouput a warning, if this definition
								is effectless */
							if( parser->p_mode != MODE_SENSITIVE )
							{
								p_error( parser, ERR_NO_EFFECT_IN_MODE,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, line,
											"lexem separation" );
							}
							else
								parser->p_lexem_sep = !@2;
						*]

					| "case insensitive strings"	boolean_opt
						[*	parser->p_cis_strings = !@2;	*]

					| "reserve terminals"			boolean_opt
						[*	parser->p_reserve_regex = !@2;		*]

					| "prologue"					code
						[*	parser->p_header = p_str_append(
								parser->p_header, strbuf, FALSE );	*]

					| "epilogue"					code
						[*	parser->p_footer = p_str_append(
								parser->p_footer, strbuf, FALSE );	*]
					| "pcb"							code
						[*	parser->p_pcb = p_str_append(
								parser->p_pcb, strbuf, FALSE );	*]

					| "option"? line_number @USERDEF:key userparam
						[*
							set_option( &( parser->options ),
								@key, strbuf, @line_number );

							pfree( @key );
							strbuf = (char*)NULL;
						*]

					;

boolean_opt<BOOLEAN>->	boolean
					|					[*	@@ = FALSE; *]
					;

boolean<BOOLEAN>	->	"on"			[*	@@ = FALSE; 	*]
					| 	"off"			[*	@@ = TRUE; 		*]
					;

symbol_list<LIST*>	->	symbol_list sym
						[*	@@ = list_push( @1, (void*)@2 ); *]

					| sym
						[*	@@ = list_push( (LIST*)NULL, (void*)@1 ); *]
					;

lhs<SYMBOL*>		->	identifier
						[*	@@ = p_get_symbol( parser,
									strbuf, SYM_NON_TERMINAL, TRUE );
							@@->defined = TRUE;
							@@->line = line;
						*]
					;
					
alt_lhs_list<LIST*>	-> alt_lhs_list lhs

						[*	@@ = list_push( @1, (void*)@2 ); *]

					| lhs

						[*	@@ = list_push( (LIST*)NULL, (void*)@1 ); *]
					;
					
alt_regex_sym<LIST*>
					-> alt_regex_sym regex_sym

						[*	@@ = list_push( @alt_regex_sym,
									(void*)@regex_sym ); 
							@regex_sym->derived_from =
								(SYMBOL*)list_access( @alt_regex_sym );
						*]

					| regex_sym

						[*	@@ = list_push( (LIST*)NULL,
									(void*)@regex_sym );

							current_sym = @regex_sym;
						*]
					;
					
regex_sym<SYMBOL*>	-> identifier
						[*	@@ = p_get_symbol( parser,
									strbuf, SYM_REGEX_TERMINAL, TRUE );

										
							if( @@->defined )
							{
								p_error( parser, ERR_DOUBLE_TERMINAL_DEF,
									ERRSTYLE_FATAL, @@->name );
							}

							@@->defined = TRUE;
							@@->line = line;
						*]
					;

definition			->	lhs:primary
						goal_mark:is_goal
						alt_lhs_list?:all type
						"->" productions
						
						[*
							LIST* 	l;
							PROD* 	p;
							SYMBOL*	lhs;
							VTYPE*	vt		= (VTYPE*)NULL;
							
							@all = list_push( @all, (void*)@primary );

							/* Value type */
							if( @type )
							{
								vt = p_create_vtype( parser,
										(uchar*)@type );

								p_free( @type );
							}

							/* Connect left-hand sides */
							for( l = @all; l; l = list_next( l ) )
							{
								lhs = (SYMBOL*)list_access( l );
								lhs->productions = list_dup( @productions );
								lhs->vtype = vt;
							}
							
							/* Link productions with this left-hand sides */
							for( l = @productions; l; l = l->next )
							{
								p = (PROD*)list_access( l );
								
								p->lhs = @primary;
								p->all_lhs = list_dup( @all );
							}

							list_free( @productions );
							list_free( @all );
							
							/* Goal primary defined? */
							if( @is_goal )
							{
								if( parser->goal )
								{
									p_error( parser, ERR_MULTIPLE_GOAL_DEF,
										ERRSTYLE_FATAL,
											parser->goal->name );
								}
								else
								{
									parser->goal = @primary;
									parser->goal->used = TRUE;
								}
							}
						*]

					| '@' alt_regex_sym type regex code_opt sym_option* 
					
						[*
							SYMBOL*	primary;
							SYMBOL* s;
							LIST* l;
							VTYPE*	vt;
							
							primary = (SYMBOL*)list_access( @alt_regex_sym );
							set_nfa_to_symbols( primary, @4.start, @4.end );

							/* Attach code */
							if( @code_opt )
							{
								primary->code = strbuf;
								primary->code_at = last_code_begin;
								strbuf = (uchar*)NULL;
							}

							/* Value type */
							if( @type )
							{
								vt = p_create_vtype( parser, @type );

								for( l = @alt_regex_sym; l;
									l = list_next( l ) )
								{
									s = (SYMBOL*)list_access( l );
									s->vtype = vt;
								}

								p_free( @type );
							}

							/* re_dbg_print_nfa( s->nfa_def,
								parser->p_universe ); */
							
							/* Assign the list of all possible symbols to
								the primary symbol */
							primary->all_sym = @alt_regex_sym;

							current_sym = (SYMBOL*)NULL;
						*]
					;

sym_option			->	'#' "option"? line_number @USERDEF:key userparam

						[*
							set_option( &( current_sym->options ), @key,
											strbuf, @line_number );

							strbuf = (uchar*)NULL;
							pfree( @key );
						*]
					;

goal_mark<BOOLEAN>	-> '$'
						[*	@@ = TRUE; *]

					|	[*	@@ = FALSE; *]
					;

productions<LIST*>	->	productions '|' production
						[*	@@ = list_push( @1, @3 ); *]

					| production
						[*	@@ = list_push( (LIST*)NULL, @1 ); *]
					;
					
production<PROD*>	->	line_number rhs_opt:rhs code_opt_dup:act
							prod_directives*
						[*
							@rhs->line = @line_number;

							if( @act )
							{
								@rhs->code = @act;
								@rhs->code_at = last_code_begin;
							}

							@@ = @rhs;
							
							current_prod = (PROD*)NULL;
						*]
					;

rhs_opt<PROD*>		->	rhs

					|	[*	@@ = p_create_production( parser,
								(SYMBOL*)NULL );
						*]
					;
					
prod_directives<int>
					-> 	'#' "precedence" terminal

						[*	current_prod->prec = @terminal->prec; *]

					|	'#' "option"? line_number @USERDEF:key userparam

						[* 	set_option( &( current_prod->options ),
								@key, strbuf, @line_number );

							strbuf = (uchar*)NULL;
							pfree( @key );
						*]
					
					;

rhs<PROD*>			->	rhs symbol access_name

						[*	p_append_to_production( @1, @2,
								( *strbuf == '\0' ? (uchar*)NULL :
											p_strdup( strbuf ) ) );
									@@ = @1;
								*]

					|	symbol access_name
					
						[*	@@ = current_prod =
								p_create_production( parser,
									(SYMBOL*)NULL );

							p_append_to_production( @@, @1,
								( *strbuf == '\0' ? (uchar*)NULL :
									p_strdup( strbuf ) ) );
						*]
					;

symbol<SYMBOL*>		->	sym modifier	

						[*
							switch( @2 )
							{
								case '*':
									@@ = p_kleene_closure( parser, @1 );
									break;
								case '+':
									@@ = p_positive_closure( parser, @1 );
									break;
								case '?':
									@@ = p_optional_closure( parser, @1 );
									break;
								default:
									@@ = @1;
									break;
							}
						*]

					|	"&error"

						[*	@@ = p_get_symbol( parser,
									P_ERROR_RESYNC, SYM_ERROR_RESYNC,
										TRUE );
							@@->used = TRUE;
							@@->defined = TRUE;
						*]
					;

sym<SYMBOL*>		-> terminal

					| identifier
					
						[*	@@ = p_get_symbol( parser,
									strbuf, SYM_NON_TERMINAL, TRUE );
							@@->used = TRUE;
						*]
						
					//Embedded productions
					| type '('  stack_cur_prod productions ')'
							
						[*
							uchar	temp_nonterm[ ONE_LINE + 1 ];
							PROD*	prod;
							LIST*	l;
							
							sprintf( temp_nonterm, P_EMBEDDED,
									embedded_count++ );
							
							@@ = p_get_symbol( parser,
									temp_nonterm, SYM_NON_TERMINAL,
										TRUE );
							@@->defined = TRUE;
							@@->used = TRUE;
							@@->generated = TRUE;

							/* Value type */
							if( @type )
							{
								VTYPE*	vt;

								vt = p_create_vtype( parser,
										(uchar*)@type );
								@@->vtype = vt;

								p_free( @type );
							}
							
							/* Associate the productions */
							@@->productions = @productions;
							current_prod = @stack_cur_prod;

							/* Link productions with this left-hand side */
							for( l = @@->productions; l; l = list_next( l ) )
							{
								prod = (PROD*)list_access( l );

								prod->lhs = @@ ;
								prod->all_lhs = list_push( (LIST*)NULL, @@ );
								make_semantic_rhs( prod );
							}
						*]
					;
					
stack_cur_prod<PROD*>
					->	[* 	@@ = current_prod;
							current_prod = (PROD*)NULL;
						*]
					;

terminal<SYMBOL*>	->	ccl				

						[*	CCL		ccl;

							ccl = ccl_create( strbuf );
							if( @1 )
								ccl_negate( ccl );

							@@ = p_get_symbol( parser,
									(void*)ccl,
										SYM_CCL_TERMINAL, TRUE );
									
							@@->defined = TRUE;
							@@->used = TRUE;
						*]

					| kw
					
						[*	@@ = p_get_symbol( parser,
									strbuf, SYM_REGEX_TERMINAL, TRUE );

							@@->used = TRUE;
							@@->defined = TRUE;
							@@->keyword = TRUE;
							
							if( pregex_nfa_from_string(
								&( @@->nfa ), strbuf,
									parser->p_cis_strings ?
										REGEX_MOD_INSENSITIVE :
											REGEX_MOD_NONE, @@->id )
										!= ERR_OK )
									OUTOFMEM;
						*]

					| '@' identifier
					
						[*	@@ = p_get_symbol( parser,
									strbuf, SYM_REGEX_TERMINAL, TRUE );

							/* @@->defined = TRUE; 
							DO NOT SET DEFINED! */
							@@->used = TRUE;
						*]
					;

modifier<int>		->	'*'
						[*	@@ = (int)'*';	*]

					| 	'+'
						[*	@@ = (int)'+'; 	*]

					|	'?'
						[*	@@ = (int)'?';	*]

					|
						[*	@@ = 0; 		*]

					;

access_name			->	':' identifier
					|	':'	string_single
					|	[*	reset_strbuf(); *]
					;

/* Regular Expression parser and NFA generator */
regex<struct @@prefix_nfa>

					->	re_alt

					;

re_alt<struct @@prefix_nfa>

					->	re_alt '|' re_expr	

						[*	@@.start = pregex_nfa_create_state
									( &nfa_m, (uchar*)NULL,
										REGEX_MOD_NONE );
							@@.end = pregex_nfa_create_state
									( &nfa_m, (uchar*)NULL,
										REGEX_MOD_NONE );

							@@.start->next = @1.start;
							@@.start->next2 = @3.start;

							@1.end->next = @@.end;
							@3.end->next = @@.end;
						*]

					| re_expr

					;

re_expr<struct @@prefix_nfa>

					->	re_expr re_modifier

						[*	@@.start = @1.start;
							@@.end = @2.end;
							@1.end->next = @2.start;
						*]

					| re_modifier

					;

re_modifier<struct @@prefix_nfa>	
					->	re_factor '*'
					
						[*	@@.start = pregex_nfa_create_state(
								&nfa_m, (uchar*)NULL, REGEX_MOD_NONE );
							@@.end = pregex_nfa_create_state(
								&nfa_m, (uchar*)NULL, REGEX_MOD_NONE );

							@@.start->next = @1.start;
							@@.start->next2 = @@.end;
							@@.end->next2 = @@.start;

							@1.end->next = @@.end;
						*]

					| re_factor '+'	

						[*	@@.start = @1.start;
							@@.end = @1.end;
							@@.end->next2 = @@.start;
						*]

					| re_factor '?'
					
						[*	@@.start = pregex_nfa_create_state(
								&nfa_m, (uchar*)NULL, REGEX_MOD_NONE );

							@@.start->next = @1.start;
							@@.start->next2 = @1.end;
							@@.end = @1.end;
						*]

					| re_factor
				;

re_factor<struct @@prefix_nfa>		
				->	ccl
				
					[*	@@.start = pregex_nfa_create_state(
									&nfa_m, strbuf, REGEX_MOD_NONE );
							@@.end = @@.start->next
								= pregex_nfa_create_state(
									&nfa_m, (uchar*)NULL, REGEX_MOD_NONE );

							if( @1 )
								ccl_negate( @@.start->ccl );
					*]

				| kw
				
					[*		uchar*	ch;
							
							if( *strbuf )
							{
								@@.end = @@.start =
									pregex_nfa_create_state(
										&nfa_m, (uchar*)NULL, REGEX_MOD_NONE );

								for( ch = strbuf; *ch; ch += u8_seqlen( ch ) )
								{
									@@.end->ccl =
										ccl_addrange( (CCL)NULL,
											u8_char( ch ), u8_char( ch ) );

									@@.end = @@.end->next =
									pregex_nfa_create_state(
										&nfa_m, (uchar*)NULL, REGEX_MOD_NONE );
								}
							}
					*]

				| '.'
					
					[*	@@.start = pregex_nfa_create_state(
							&( nfa_m ), (uchar*)NULL, REGEX_MOD_NONE );
						@@.start->ccl = ccl_addrange( (CCL)NULL,
							CCL_MIN, CCL_MAX - 1 );	

						@@.end = @@.start->next = pregex_nfa_create_state(
							&( nfa_m ), (uchar*)NULL, REGEX_MOD_NONE );
					*]

				| '(' regex ')'

					[*	@@.start = @2.start;
						@@.end = @2.end;
					*]
				;

/* General parsing objects */
string			->	string_single+
				;

string_single	-> ccl_string | kw
				;

ccl<BOOLEAN>	->	ccl_string

					[*	@@ = FALSE; *]

				| '!' ccl_string

					[*	@@ = TRUE; *]
				;


/* ------------------------------------- TODO: Must be re-designed... --- */
ccl_string		->	'\'' ccl_str '\'';

ccl_str			->	ccl_str ccl_char
				|
					[*	reset_strbuf(); *]
				;

ccl_char		->	!'\\\''	
					[*	strbuf_append( @1 ); *]

				| '\\' !'\0'					
					[* 	strbuf_append( (uchar)'\\' );
						strbuf_append( @2 ); 	  *]
				;

kw				->	'\"' kw_str '\"'
				;

kw_str			->	kw_str kw_char
					[* 	strbuf_append( @2 ); *]
				|	[*	reset_strbuf(); *]
				;
				
kw_char			->	!'\\"'
					[* 	strbuf_append( @1 ); *]

				| '\\' !'\0'
					[* 	strbuf_append( (uchar)'\\' );
						strbuf_append( @2 ); 
					*]
				;

type<uchar*>	->	'<' type_str '>'
					[*	@@ = p_strdup( strbuf ); *]
				|	[*	@@ = (uchar*)NULL; *]
				;

type_str		->	type_str !'>'
					[* 	strbuf_append( @2 ); *]
				|	[* 	reset_strbuf(); *]
				;

/*
identifier_cpy<uchar*>
				->	identifier
					[*
						@@ = pstrdup( strbuf );
						reset_strbuf();
					*]
				;
*/

identifier		->	identifier_start identifier_follow
				;

identifier_start
				->	'A-Za-z_'
					[* 	reset_strbuf();
						strbuf_append( @1 );
					*]
				;

identifier_follow
				-> identifier_follow 'A-Za-z0-9_'
					[*	strbuf_append( @2 );  *]
				|
				;
				
/* ------------------------------------- TODO: ...until here --- */

integer			->	integer '0-9'
					[*	strbuf_append( @2 ); *]

				| '0-9'
					[* 	reset_strbuf();
						strbuf_append( @1 );
					*]
				;

code_opt_dup<uchar*>
				->	code_opt
					
					[* 	@@ = p_strdup( @code_opt );
						reset_strbuf();
					*]
				;

code_opt<uchar*>->	code
					[*	@@ = strbuf; *]
				|	[*	reset_strbuf();
						@@ = (uchar*)NULL; *]
				;

code			->	code_begin inner_code_opt "*]"				
					[*
						if( !parser->p_language )
						{
							p_error( parser,
								ERR_NO_TARGET_LANG_SUPPLY,
									ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
										parser->filename, last_code_begin );
								
							reset_strbuf();
						}
					*]
				;
				
code_begin		->	"[*"

					[* last_code_begin = line; *]
				;

inner_code_opt	->	inner_code
				|	[*	reset_strbuf(); *]
				;

inner_code		->	inner_code anychar
					[*	strbuf_append( @2 );		*]

				|	anychar
					[*	reset_strbuf();
						strbuf_append( @1 );
					*]
				;

whitespace		-> ' '
				| '\t'
				| "/*" comment? "*/"
				| "//" scomment? '\n'

					[* line++;	*]

				| '\r'
				| '\n'
					[* line++; 	*]
				;

comment			->	comment anychar
				|	anychar
				;
				
anychar			->	!'\0'										
					[*	if( @1 == '\n' )
							line++;
						@@ = @1;
					*]
				;

scomment		->	scomment !'\n'
				| !'\n'
				;

line_number		->	[* @@ = line; *]
				;

#epilogue

[*

static void p_parse_error( @@prefix_pcb* pcb )
{
	int		i;
	uchar**	vptr;
	uchar**	valid;
	uchar*	cur;
	uchar*	bigstr;

	if( !( vptr = valid =
			(uchar**)p_malloc( ( @@prefix_act[ *( pcb->tos ) ][0] + 1 )
						* sizeof( uchar* ) ) ) )
		OUTOFMEM;

	for( i = 1; i < @@prefix_act[ *( pcb->tos ) ][0] * 3; i += 3 )
		*( vptr++ ) = @@prefix_symbol_names[ _act[ *( pcb->tos ) ][i] ];

	*vptr = (uchar*)NULL;

	if( pcb->sym == -1 )
		cur = pcb->buf;
	else
		cur = @@prefix_symbol_names[ pcb->sym ];

	p_error( parser, ERR_PARSE_ERROR,
				ERRSTYLE_FATAL | ERRSTYLE_FILEINFO,
					parser->filename, pcb->line, cur, valid );
}

int p_parse( PARSER* p, uchar* src )
{
	@@prefix_pcb pcb;

	line = 1;
	auto_regex = 0;
	prec_cnt = 1;
	directive_level = 0;
	embedded_count = 0;
	memset( &pcb, 0, sizeof( pcb ) );

	if( p && src )
	{
		parser = p;
		strbuf_append( '\0' );

		src_ptr = src;

		@@prefix_parse( &pcb );
		
		p_free( strbuf );
	}

	return pcb.error_count + error_count;
}

*];
