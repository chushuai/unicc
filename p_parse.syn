{/* -MODULE----------------------------------------------------------------------
UniCC LALR(1) Parser Generator 
Copyright (C) 2006-2009 by Phorward Software Technologies, Jan Max Meyer
http://unicc.phorward-software.com/ ++ unicc<<AT>>phorward-software<<DOT>>com

File:	p_parse.syn/p_parse.c
Author:	Jan Max Meyer
Usage:	Grammar definition parser

You may use, modify and distribute this software under the terms and conditions
of the Artistic License, version 2. Please see LICENSE for more information.
----------------------------------------------------------------------------- */

/*
 * Includes
 */
#include "p_global.h"
#include "p_proto.h"
#include "p_error.h"

/*
 * Global variables
 */

union _stack_val
{
	uchar*	str;
	uchar	ch;
	int		num;
	void*	ptr;
	BOOLEAN	negative;
	
	struct
	{
		NFA*	start;
		NFA*	end;
	} nfa;
};

#define PDEBUG 0

#define VAL union _stack_val
#define SET_CURRENT_CHAR .ch

#ifndef uchar
#define uchar unsigned char
#endif

#ifndef MALLOC_STEP
#define MALLOC_STEP 255
#endif

PARSER*	parser	= (PARSER*)NULL;

int	directive_level	= 0; /* Directive level */
int	prec_cnt		= 1; /* Precedence level */
int	line			= 1; /* Line within source file */
int auto_regex		= 0; /* Nameless Regex counter */
BOOLEAN	footer_code	= FALSE; /* Flag for footer code recognition */

extern int	error_count;

uchar*	strbuf	= (uchar*)NULL;
LIST*	nfa_m	= (LIST*)NULL;


/*
 * Functions
 */

/* Append character to current string */
void strbuf_append( uchar ch )
{
	int len;
	len = strbuf ? (int)strlen( strbuf ) : 0;

	if( !strbuf )
		strbuf = (uchar*)p_malloc( ( MALLOC_STEP + 2 ) * sizeof( uchar ) );
	else if( len % MALLOC_STEP == 0 )
		strbuf = (uchar*)p_realloc( (uchar*)strbuf, ( len + MALLOC_STEP + 2 ) * sizeof( uchar ) );

	strbuf[len] = ch;
	strbuf[len+1] = '\0';
	strbuf[len+2] = '\0';
}

void strbuf_prefix( uchar ch )
{
	int len;
	uchar* tmp;
	len = strbuf ? (int)strlen( strbuf ) : 0;

	if( !strbuf )
		strbuf = (uchar*)p_malloc( ( MALLOC_STEP + 2 ) * sizeof( uchar ) );
	else if( len % MALLOC_STEP == 0 )
		strbuf = (uchar*)p_realloc( (uchar*)strbuf, ( len + MALLOC_STEP + 2 ) * sizeof( uchar ) );

	tmp = p_strdup( strbuf );
	sprintf( strbuf, "%c%s%c", ch, tmp, '\0' );
	p_free( tmp );
}

/* Create a new string */
void reset_strbuf( void )
{
	if( strbuf )
	{
		*strbuf = '\0';
		*(strbuf+1) = '\0';
	}
}


/* Set precedence and associativiy */
void set_assoc_and_prec( LIST* symbols, int assoc )
{
	LIST* l;
	SYMBOL* sym;
	
	for( l = symbols; l; l = l->next )
	{
		sym = l->pptr;
		sym->prec = prec_cnt;
		sym->assoc = assoc;
	}
	
	list_free( symbols );
	prec_cnt++;
}

void set_nfa_to_symbols( SYMBOL* s, NFA* start, NFA* end )
{
	NFA*	nstart;
	
	nstart = re_create_nfa( &( s->nfa_def ) );
	nstart->next = start;
	end->accept = s->id;
	
	s->nfa_def = list_union( s->nfa_def, nfa_m );
	nfa_m = list_free( nfa_m );
	
	s->keyword = TRUE;
}

/*
 * Parser definition
 */
}

~ whitespace;
$ sym modifier code ccl_string kw type;

grammar_spec:	fixed_directives segments
				;
				
segments:		segments segment
				|
				;
				
fixed_directives:	fixed_directives "#!" fixed_directive ';'
				|
				;
				
fixed_directive: "model"				model_type
				| "character universe"	integer					{	int universe = atoi( strbuf );
				
																	if( universe > 0 )
																		parser->p_universe = universe;
																	else
																		p_error( ERR_INVALID_CHAR_UNIVERSE,
																			ERRSTYLE_FATAL | ERRSTYLE_FILEINFO,
																				parser->filename, line );
																}
				;

model_type:		"context-sensitive"								{	parser->p_model = MODEL_CONTEXT_SENSITIVE;	}
				| "context-insensitive"							{	parser->p_model = MODEL_CONTEXT_INSENSITIVE;}
				;

segment:		code
				| definition ';'
				| unfixed_directive ';';

unfixed_directive:	'#' directive_parms ;

directive_parms: "whitespaces"		symbol_list					{	LIST* l;
																	SYMBOL* s;
																	
																	for( l = #2.ptr; l; l = l->next )
																	{
																		s = l->pptr;

																		/* Do not allow nonterminal definitions here
																			in conext-free model */
																		if( s->type == SYM_NON_TERMINAL &&
																			parser->p_model !=
																				MODEL_CONTEXT_SENSITIVE )
																		{
																			p_error( ERR_NONTERM_WS_NOT_ALLOWED,
																				ERRSTYLE_FATAL | ERRSTYLE_FILEINFO,
																						parser->filename, line,
																							s->name );
																		}
																		else
																			s->whitespace = TRUE;
																	}
																	
																	list_free( #2.ptr );
																}
				| "lexeme separation" boolean					{	/* Ouput a warning, if this definition
																		is effectless */
																	if( parser->p_model != MODEL_CONTEXT_SENSITIVE )
																	{
																		p_error( ERR_NO_EFFECT_IN_MODEL,
																			ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
																				parser->filename, line,
																					"lexem separation" );
																	}
																	else
																		parser->p_lexem_sep = !(#2.negative);	}
				| "lexeme"			symbol_list					{	LIST* l;
																	SYMBOL* s;
																	
																																		
																	/* Ouput a warning, if this definition
																		is effectless */
																	if( parser->p_model != MODEL_CONTEXT_SENSITIVE )
																	{
																		p_error( ERR_NO_EFFECT_IN_MODEL,
																			ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
																				parser->filename, line, "lexeme" );
																	}
																	else
																	{																	
																		for( l = #2.ptr; l; l = l->next )
																		{
																			s = l->pptr;
																			s->lexem = TRUE;
																		}
																	}
																	
																	list_free( #2.ptr );

																}
				| "fixate" 			symbol_list					{	LIST* l;
																	SYMBOL* s;
																	
																	/* Ouput a warning, if this definition
																		is effectless */
																	if( parser->p_model != MODEL_CONTEXT_SENSITIVE )
																	{
																		p_error( ERR_NO_EFFECT_IN_MODEL,
																			ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
																				parser->filename, line, "fixate" );
																	}
																	else
																	{																	
																		for( l = #2.ptr; l; l = l->next )
																		{
																			s = l->pptr;
																			s->fixated = TRUE;
																		}
																	}
																	
																	list_free( #2.ptr );

																}
				| "left"			symbol_list					{	set_assoc_and_prec( #2.ptr, ASSOC_LEFT ); 	}
				| "right"			symbol_list					{	set_assoc_and_prec( #2.ptr, ASSOC_RIGHT ); 	}
				| "nonassoc"		symbol_list					{	set_assoc_and_prec( #2.ptr, ASSOC_NOASSOC ); 	}
				| "parser"			string						{	if( !( parser->p_name ) )
																		parser->p_name = p_strdup( strbuf );	}
				| "description"		string						{	if( !( parser->p_desc ) )
																		parser->p_desc = p_strdup( strbuf );	}
				| "copyright"		string						{	if( !( parser->p_copyright ) )
																		parser->p_copyright = p_strdup( strbuf );
																}
				| "version"			string						{	if( !( parser->p_version ) )
																		parser->p_version= p_strdup( strbuf );	}
				| "prefix"			string						{	if( !( parser->p_prefix ) )
																		parser->p_prefix = p_strdup( strbuf );	}
				| "language"		string						{	if( !( parser->p_language ) )
																			parser->p_language = p_strdup( strbuf );
																}
				| "default action"	code						{	if( !( parser->p_def_action ) )
																			parser->p_def_action = p_strdup( strbuf );
																}
				| "default epsilon action"		code			{	if( !( parser->p_def_action_e ) )
																			parser->p_def_action_e = p_strdup( strbuf );
																}
				| "end of input"	terminal					{	parser->end_of_input = #2.ptr;				}
				| "invalid keyword suffix"	ccl					{	/* Ouput a warning, if this definition
																		is effectless */
																	if( parser->p_model != MODEL_CONTEXT_SENSITIVE )
																	{
																		p_error( ERR_NO_EFFECT_IN_MODEL,
																			ERRSTYLE_WARNING | ERRSTYLE_FILEINFO,
																				parser->filename, line,
																					"invalid keyword suffix" );
																	}
																	else
																	{
																		parser->p_invalid_suf = p_strdup( strbuf );
																		parser->p_neg_inv_suf = #2.negative;
																	}
																}
				| "case insensitive keywords"	boolean			{	parser->p_cis_keywords = !(#2.negative);	}
				| "prologue"					code			{	parser->p_header = p_str_append( 
																		parser->p_header, strbuf, FALSE );		}
				| "epilogue"					code			{	parser->p_footer = p_str_append( 
																		parser->p_footer, strbuf, FALSE );		}
				;

boolean:		"on"											{	##.negative = FALSE; 						}
				| "off"											{	##.negative = TRUE; 						}
				|												{	##.negative = FALSE; 						}
				;
				
symbol_list:	symbol_list sym									{	##.ptr = list_push( #1.ptr, #2.ptr ); 		}
				| sym											{	##.ptr = list_push( (LIST*)NULL, #1.ptr );	}
				;

definition:		lhs goal_mark type "->" productions				{
																	LIST* l;
																	PROD* p;
																	
																	((SYMBOL*)(#1.ptr))->productions = #5.ptr;
																	
																	if( #2.ch == '$' )
																	{
																		if( parser->goal )
																		{
																			p_error( ERR_MULTIPLE_GOAL_DEF,
																				ERRSTYLE_FATAL,
																					parser->goal->name );
																		}
																		else
																		{
																			parser->goal = #1.ptr;
																			parser->goal->used = TRUE;
																		}
																	}
																	
																	/* Link productions with this left-hand side */
																	for( l = #5.ptr; l; l = l->next )
																	{
																		p = l->pptr;
																		p->lhs = #1.ptr;
																	}
																	
																	/* Value type */
																	if( #3.ptr )
																	{
																		VTYPE*	vt;
																		
																		vt = p_create_vtype( parser, 
																				(uchar*)(#3.ptr) );
																		((SYMBOL*)(#1.ptr))->vtype = vt;
																		
																		p_free( #3.ptr );
																	}
																}
				| '@' identifier_copy type regex code_opt		{	SYMBOL* s;
																	s = p_get_symbol( parser,
																			#2.str, SYM_REGEX_TERMINAL, TRUE );
																	
																	p_free( #2.str );
																	
																	set_nfa_to_symbols( s, #4.nfa.start, #4.nfa.end );
																	
																	/* Attach code */
																	if( strbuf && *strbuf )
																	{
																		s->code = strbuf;
																		strbuf = (uchar*)NULL;
																	}
																	
																	/* Value type */
																	if( #3.ptr )
																	{
																		VTYPE*	vt;
																		
																		vt = p_create_vtype( parser,
																				(uchar*)(#3.ptr) );
																		s->vtype = vt;
																		p_free( #3.ptr );
																	}

																	/* re_dbg_print_nfa( s->nfa_def,
																		parser->p_universe ); */
																}
				;
				
lhs:			identifier										{	SYMBOL* s;
																	s = p_get_symbol( parser,
																			strbuf, SYM_NON_TERMINAL, TRUE );
																	s->defined = TRUE;
																			
																	##.ptr = s;
																}
				;
				
goal_mark:		'$'												{	##.ch = '$'; }
				|												{	##.ch = '\0'; }
				;
				
productions:	productions '|' rhs code_opt					{	if( *strbuf != '\0' )
																		((PROD*)(#3.ptr))->code = p_strdup( strbuf );

																	##.ptr = list_push( #1.ptr, #3.ptr );
																}
				| rhs code_opt									{	if( *strbuf != '\0' )
																		((PROD*)(#1.ptr))->code = p_strdup( strbuf );

																	##.ptr = list_push( (LIST*)NULL, #1.ptr );
																}
				;

rhs:			rhs symbol access_name							{	p_append_to_production( #1.ptr, #2.ptr, 
																		( *strbuf == '\0' ? (uchar*)NULL :
																			p_strdup( strbuf ) ) );
																	##.ptr = #1.ptr;
																}
				|												{	##.ptr = p_create_production( parser,
																		(SYMBOL*)NULL ); }
				;

symbol:			sym modifier 									{
																	switch( #2.ch )
																	{
																		case '*':
																			##.ptr = p_kleene_closure( parser,
																				#1.ptr );
																			break;
																		case '+':
																			##.ptr = p_positive_closure( parser,
																				#1.ptr );
																			break;
																		case '?':
																			##.ptr = p_optional_closure( parser,
																				#1.ptr );
																			break;
																		default:
																			##.ptr = #1.ptr;
																			break;
																	}
																}
				|	'#' "error"									{	SYMBOL* sym;
																	sym = p_get_symbol( parser,
																			P_ERROR_RESYNC, SYM_ERROR_RESYNC,
																				TRUE );
																	sym->used = TRUE;
																	sym->defined = TRUE;
																	
																	##.ptr = sym;
																}
				;
				
sym:			terminal										{	##.ptr = #1.ptr; 	}
				| identifier									{	SYMBOL* s;
																	s = p_get_symbol( parser,
																			strbuf, SYM_NON_TERMINAL, TRUE );
																	s->used = TRUE;
																	##.ptr = s;
																}
				;
				
terminal:		ccl												{ 	SYMBOL* s;
																	char* name = strbuf;

																	if( #1.negative )
																		name = p_negate_ccl( parser, name );

																	s = p_get_symbol( parser, 
																			name, SYM_CCL_TERMINAL, TRUE );

																	s->used = TRUE;
																	s->defined = TRUE;
																	##.ptr = s;
																	
																	if( #1.negative )
																		p_free( name );
																}
				| kw											{ 	SYMBOL* s;
																	s = p_get_symbol( parser,
																			strbuf, SYM_KW_TERMINAL, TRUE );

																	s->used = TRUE;
																	s->defined = TRUE;

																	s->keyword = TRUE;
																	##.ptr = s;
																}
				| integer										{	SYMBOL* s;
																	s = p_get_symbol( parser,
																			strbuf, SYM_EXTERN_TERMINAL, TRUE );
																	s->used = TRUE;
																	s->defined = TRUE;

																	##.ptr = s;
																}
				| '@' identifier								{	SYMBOL* s;
																	s = p_get_symbol( parser,
																			strbuf, SYM_REGEX_TERMINAL, FALSE );

																	s->used = TRUE;
																	s->defined = TRUE;

																	##.ptr = s;
																}
				/*
				| '~'											{	##.ptr = p_get_symbol( parser,
																			"", SYM_ERROR, TRUE );												}
				*/
				;

modifier:		'*'												{	##.ch = '*';	}
				| '+'											{	##.ch = '+'; 	}
				| '?'											{	##.ch = '?';	}
				|												{	##.ch = '\0'; 	}
				;
				
access_name:	':' identifier
				|												{	reset_strbuf(); }
				;

/* Regular Expression parser and NFA generator */
regex:			re_alt
				;

re_alt:			re_alt '|' re_expr								{	##.nfa.start = re_create_nfa( &nfa_m );
																	##.nfa.end = re_create_nfa( &nfa_m );
																	
																	##.nfa.start->next = #1.nfa.start;
																	##.nfa.start->next2 = #3.nfa.start;
																	
																	#1.nfa.end->next = ##.nfa.end;
																	#3.nfa.end->next = ##.nfa.end;
																}
				| re_expr
				;

re_expr:		re_expr re_modifier								{	##.nfa.start = #1.nfa.start;
																	##.nfa.end = #2.nfa.end;
																	#1.nfa.end->next = #2.nfa.start;
																}
				| re_modifier
				;
				
re_modifier:	re_factor '*'									{	##.nfa.start = re_create_nfa( &nfa_m );
																	##.nfa.end = re_create_nfa( &nfa_m );
																	
																	##.nfa.start->next = #1.nfa.start;
																	##.nfa.start->next2 = ##.nfa.end;
																	##.nfa.end->next2 = ##.nfa.start;
																	
																	#1.nfa.end->next = ##.nfa.end;
																}
				| re_factor '+'									{	##.nfa.start = #1.nfa.start;
																	##.nfa.end = #1.nfa.end;
																	##.nfa.end->next2 = ##.nfa.start;
																}
				| re_factor '?'									{	##.nfa.start = re_create_nfa( &nfa_m );
																		
																	##.nfa.start->next = #1.nfa.start;
																	##.nfa.start->next2 = #1.nfa.end;
																	##.nfa.end = #1.nfa.end;
																}
				| re_factor
				;

re_factor:		ccl												{	uchar*	tmp;
																	##.nfa.start = re_create_nfa( &nfa_m );
																	##.nfa.end = ##.nfa.start->next
																		= re_create_nfa( &nfa_m );
																		
																	##.nfa.start->edge = CCL;
																	if( #1.negative )
																	{
																		tmp = p_negate_ccl( parser, strbuf );
																		
																		##.nfa.start->cclass = 
																			p_ccl_to_map( parser, tmp );
																			
																		p_free( tmp );
																	}
																	else
																		##.nfa.start->cclass =
																			p_ccl_to_map( parser, strbuf );
																}
				| kw											{	uchar*	ch;
																	
																	if( *strbuf )
																	{
																		##.nfa.end = ##.nfa.start = re_create_nfa(
																			&nfa_m );
																		
																		for( ch = strbuf; *ch; ch++ )
																		{
																			##.nfa.end->edge = *ch;
																			
																			##.nfa.end = ##.nfa.end->next
																				= re_create_nfa( &nfa_m );
																		}
																	}
																}
				| '.'											{	int i;

																	##.nfa.start = re_create_nfa(
																		&( nfa_m ) );
																	##.nfa.end = ##.nfa.start->next
																		= re_create_nfa(
																			&( nfa_m ) );
																		
																	##.nfa.start->edge = CCL;
																	##.nfa.start->cclass =
																		bitset_create( parser->p_universe );
																	
																	for( i = 0; i < parser->p_universe; i++ )
																		bitset_set( ##.nfa.start->cclass, i, 1 );
																}
				| '(' regex ')'									{	##.nfa.start = #2.nfa.start;
																	##.nfa.end = #2.nfa.end;
																}
				;

/* General parsing objects */
string:			ccl_string | kw;

ccl:		ccl_string											{	##.negative = FALSE; }
			| '!' ccl_string									{	##.negative = TRUE; }
			;

ccl_string:	'\'' ccl_str '\''
			;
		
ccl_str:	ccl_str ccl_char
			|													{ 	reset_strbuf(); }
			;
			
ccl_char:	'^\'\\'												{ strbuf_append( (uchar)#1.ch ); }
			| '\\' '^'											{ strbuf_append( (uchar)'\\' );
																  strbuf_append( (uchar)#2.ch ); }
			;

kw:			'\"' kw_str '\"';
	
kw_str:		kw_str '^\"'										{ 	strbuf_append( (uchar)#2.ch ); }
			|													{ 	reset_strbuf(); }
			;
			
type:		'<' type_str '>'									{	##.ptr = p_strdup( strbuf );	}
			|													{	##.ptr = (void*)NULL; }
			;
	
type_str:	type_str '^>'										{ 	strbuf_append( (uchar)#2.ch ); }
			|													{ 	reset_strbuf(); }
			;

/*
escape_sequence:
			'a'													{ 	##.ch = '\a'; }
			| 'b'												{ 	##.ch = '\b'; }
			| 'n'												{ 	##.ch = '\n'; }
			| 'f'												{ 	##.ch = '\f'; }
			| 'r'												{ 	##.ch = '\r'; }
			| 't'												{ 	##.ch = '\t'; }
			| 'v'												{ 	##.ch = '\v'; }
			| '\\'												{ 	##.ch = '\\'; }
			| '?'												{ 	##.ch = '\?'; }
			| '\''												{ 	##.ch = '\''; }
			| '\"'												{ 	##.ch = '\"'; }
			| '0'												{ 	##.ch = '\0'; }
			;
*/

identifier_copy:	identifier									{	##.str = strbuf;
																	strbuf = (uchar*)NULL;
																}
			;

identifier:	identifier_start identifier_follow
			;
			
identifier_start: 'A-Za-z_'										{ 	reset_strbuf();
																	strbuf_append( #1.ch ); }
			;
			
identifier_follow: identifier_follow 'A-Za-z0-9_'				{	strbuf_append( #2.ch ); }
			|
			;

integer:	integer '0-9'										{	strbuf_append( #2.ch ); }
			| '0-9'												{ 	reset_strbuf();
																	strbuf_append( #1.ch );
																}
			;

code_opt:	code
			|													{	reset_strbuf(); }
			;

code:		"[*" inner_code "*]"
			;

inner_code:	inner_code '^'										{	strbuf_append( #2.ch ); }
			|													{	reset_strbuf(); }
			;

whitespace: ' '
			| '\t'
			| "/*" comment "*/"
			| "//" scomment '\n'
			| '\r'
			| '\n' { line++; }
			;

comment:	comment '^'
			|
			;
			
scomment:	scomment '^\n'
			|
			;

{

int p_parse( PARSER* p, uchar* src )
{
	char* s,
		* sp;
	int err = -1;
	
	line = 1;
	auto_regex = 0;
	prec_cnt = 1;
	directive_level = 0;
	
	if( p && src )
	{
		err = 0;

		parser = p;
		strbuf_append( '\0' );
	
		s = sp = src;
		
		#if PDEBUG
		printf( "<<< %s >>>\n", s );
		#endif
		err = parse( s );
		
		p_free( strbuf );
	}
		
	return err + error_count;
}

}

