<?xml version="1.0" standalone="yes"?>
<generator name="Python" long-name="UniCC Standard Python Template" version="0.2">
	<escape-sequence for="\" do="\\" />
	<escape-sequence for="&#x22;" do="\&#x22;" />
	<code_localization />

	<vstack_def_type>any</vstack_def_type>
	<vstack_term_type>any</vstack_term_type>
	<vstack_union_att>@@value-type-id</vstack_union_att>
	<vstack_union_def>@@attribute: None, </vstack_union_def>
	<vstack_single>value = None</vstack_single>
	<vstack_union_start>value = {</vstack_union_start>
	<vstack_union_end>}</vstack_union_end>

	<action_start>&#x09;def _reduce_action_@@production-number(self, pcb):&#x0A;&#x09;&#x09;</action_start>
	<action_end>&#x0A;&#x09;&#x09;return&#x0A;&#x0A;</action_end>
	<action_single>pcb.stack[-1 - @@offset].value</action_single>
	<action_union>pcb.stack[-1 - @@offset].value[@@attribute]</action_union>
	<action_lhs_single>pcb.ret</action_lhs_single>
	<action_lhs_union>pcb.ret[@@attribute]</action_lhs_union>

	<action_set_lhs>pcb.lhs = @@sym</action_set_lhs>

	<scan_action_start>&#x09;def _scan_action_@@symbol-number(self, shift = True):&#x0A;&#x09;&#x09;</scan_action_start>
	<scan_action_end>&#x0A;&#x09;&#x09;return&#x0A;&#x0A;</scan_action_end>
	<scan_action_begin_offset>pcb.buf</scan_action_begin_offset>
	<scan_action_end_offset>pcb.length</scan_action_end_offset>
	<scan_action_ret_single>pcb.tos.value</scan_action_ret_single>
	<scan_action_ret_union>pcb.tos.value[@@attribute]</scan_action_ret_union>
	<scan_action_set_symbol>pcb.sym = @@sym</scan_action_set_symbol>

	<defprod>
		<col>@@production-number</col>
		<col_sep>, </col_sep>
	</defprod>

	<acttab>
		<row_start>&#x09;&#x09;(</row_start>
		<row_end>)</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>(@@symbol, @@action, @@index), </col>
		<col_sep></col_sep>
	</acttab>

	<gotab>
		<row_start>&#x09;&#x09;(</row_start>
		<row_end>)</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>(@@symbol, @@action, @@index), </col>
		<col_sep></col_sep>
	</gotab>

	<dfa_select>
		<col>@@machine</col>
		<col_sep>, </col_sep>
	</dfa_select>

	<dfa_char>
		<col>(@@from, @@to)</col>
		<col_sep>, </col_sep>
	</dfa_char>

	<dfa_trans>
		<col>@@goto</col>
		<col_sep>, </col_sep>
	</dfa_trans>

	<dfa_idx>
		<row_start>&#x09;&#x09;(</row_start>
		<row_end>)</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@index</col>
		<col_sep>, </col_sep>
	</dfa_idx>

	<dfa_accept>
		<row_start>&#x09;&#x09;(</row_start>
		<row_end>)</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@accept</col>
		<col_sep>, </col_sep>
	</dfa_accept>

	<symbols>
		<col>&#x09;&#x09;("@@symbol-name", @@type, @@lexem, @@whitespace, @@greedy)</col>
		<col_sep>,&#x0A;</col_sep>
	</symbols>

	<productions>
		<col>&#x09;&#x09;("@@production", @@length, @@lhs)</col>
		<col_sep>,&#x0A;</col_sep>
	</productions>

	<file filename="@@basename.py">#!/usr/bin/python
#-*- coding: utf-8 -*-

@@prologue

class @@prefixParserToken(object):
	state = 0
	line = 0
	column = 0

	@@value-type-definition

class @@prefixParserControlBlock(object):

	# Stack
	stack = []
	tos = None

	# Values
	ret = None

	# State
	act = None
	idx = None
	lhs = None

	# Lookahead
	sym = -1
	old_sym = -1
	len = 0

	# Lexical analysis
	lexem = None
	next = None
	eof = None
	is_eof = None

	# Input buffering
	input = None
	buf = ""

	# Error handling
	error_delay = 3
	error_count = 0

	line = 1
	column = 1

	@@pcb


class @@prefixParser(object):

	# Actions
	_ERROR = 0
	_REDUCE = 1
	_SHIFT = 2

	# Parse tables
	_symbols = (
@@symbols
	)
	_productions = (
@@productions
	)
	_act = (
@@action-table
	)
	_go = (
@@goto-table
	)

	_def_prod = (@@default-productions)

	# Lexical analysis
	_dfa_select = (@@dfa-select)
	_dfa_index = (
@@dfa-index
	)
	_dfa_chars = (@@dfa-char)
	_dfa_trans = (@@dfa-trans)
	_dfa_accept = (
@@dfa-accept
	)

	def _get_act(self, pcb):
		# Get action table entry

		# Check action table first
		for (sym, pcb.act, pcb.idx) in self._act[pcb.tos.state]:
			if sym == pcb.sym:
				return True if pcb.act else False #enforced parse error

		# Apply default production
		pcb.idx = self._def_prod[pcb.tos.state]
		if pcb.idx &gt; -1:
			pcb.act = self._REDUCE
			return True

		return False

	def _get_go(self, pcb):
		# Get goto table entry

		for (sym, pcb.act, pcb.idx) in self._go[pcb.tos.state]:
			if sym == pcb.lhs:
				return True

		return False

	def _get_char(self, pcb):
		# Get next character from input stream

		if callable(pcb.input):
			return pcb.input()

		if pcb.input:
			ch = pcb.input[0]
			pcb.input = pcb.input[1:]
		else:
			ch = pcb.eof

		return ch

	def _get_input(self, pcb, offset):
		# Performs input buffering

		while offset &gt;= len(pcb.buf):
			if pcb.is_eof:
				return pcb.eof

			ch = self._get_char(pcb)
			if ch == pcb.eof:
				pcb.is_eof = True
				return pcb.eof

			pcb.buf += ch

		#print("_get_input", pcb.buf, offset, pcb.buf[offset], ord(pcb.buf[offset]))

		return ord(pcb.buf[offset])

	def _clear_input(self, pcb):
		# Purge input from buffer that is not necessary anymore

		if pcb.buf:

			# Perform position counting.
			for pos in range(0, pcb.length):
				ch = pcb.buf[pos]
				if ch == '\n':
					pcb.line += 1
					pcb.column = 0
				else:
					pcb.column += 1

			pcb.buf = pcb.buf[pcb.length:]

		pcb.length = 0
		pcb.sym = -1

	def _lex(self, pcb):
		# Lexical analysis

		state = length = 0
		machine = self._dfa_select[pcb.tos.state] if not @@mode else 0
		next = self._get_input(pcb, length)

		if next == pcb.eof:
			pcb.sym = @@eof
			return

		while state &gt; -1 and next != pcb.eof:
			idx = self._dfa_index[machine][state]
			state = -1

			while self._dfa_chars[idx][0] > -1:
				if (next &gt;= self._dfa_chars[idx][0]
					and next &lt;= self._dfa_chars[idx][1]):

					state = self._dfa_trans[idx]

					if self._dfa_accept[machine][state] &gt; 0:
						length += 1
						pcb.length = length
						pcb.sym = self._dfa_accept[machine][state] - 1

						# Test! (??)
						if pcb.sym == @@eof:
							state = -1
							break

						# Stop if matched symbol should be parsed nongreedy
						if not self._symbols[pcb.sym][4]:
							state = -1
							break

						next = self._get_input(pcb, length)
						break

				idx += 1

			# TODO: Semantic Terminal Selection?

		#print("_lex", pcb.sym, pcb.length)

	def _get_sym(self, pcb):
		# Get lookahead symbol

		pcb.sym = -1
		pcb.len = 0

		# insensitive mode
		if @@mode:
			while True:
				self._lex(pcb)

				# check for whitespace
				if pcb.sym &gt; -1 and self._symbols[pcb.sym][3]:
					continue

				break

		# sensitive mode
		else:
			if self._dfa_select[pcb.tos.state] &gt; -1:
				self._lex(pcb)

			# If there is no matching DFA state machine, try to identify the
			# end-of-file symbol. If this also fails, a parse error will raise.
			elif self._get_input(pcb, 0) == pcb.eof:
				pcb.sym = @@eof

		return pcb.sym &gt; -1

@@scan_actions
@@actions

	def parse(self, s = None):
		if s is None:
			try:
				s = raw_input(">")
			except NameError:
				s = input(">")

		pcb = @@prefixParserControlBlock()
		pcb.input = s

		pcb.tos = @@prefixParserToken()
		pcb.stack.append(pcb.tos)

		while True:
			#print("pcb.tos.state = %d" % pcb.tos.state)

			# TODO: Error Recovery
			self._get_sym(pcb)

			#print("pcb.sym = %d" % pcb.sym)
			#print("pcb.length = %d" % pcb.length)

			# Get action table entry
			if not self._get_act(pcb):
				print("Parse Error")
				break

			#print("pcb.act = %d" % pcb.act)

			# Shift
			if pcb.act &amp; self._SHIFT:
				#print("SHIFT", pcb.sym, self._symbols[pcb.sym])

				pcb.tos = @@prefixParserToken()
				pcb.stack.append(pcb.tos)

				# Execute scanner actions, if existing.
				#fn = getattr(self, "scan_action_%d" % pcb.sym)()

				pcb.tos.state = -1 if pcb.act &amp; self._REDUCE else pcb.idx
				pcb.tos.symbol = self._symbols[pcb.sym]
				pcb.tos.line = pcb.line
				pcb.tos.column = pcb.column
				@@top-value = pcb.buf[:pcb.length]

				if pcb.sym != @@eof and pcb.sym != @@error:
					self._clear_input(pcb)
					pcb.old_sym = -1

			# Reduce
			while pcb.act &amp; self._REDUCE:

				# Set default left-hand side
				pcb.lhs = self._productions[pcb.idx][2]

				#print("REDUCE", pcb.idx, self._symbols[pcb.lhs])
				#print("state", pcb.tos.state)

				# Call reduce function
				#print("CALL", "_reduce_action_%d" % pcb.idx)
				getattr(self, "_reduce_action_%d" % pcb.idx)(pcb)

				# Drop right-hand side
				for _ in range(0, self._productions[pcb.idx][1]):
					pcb.stack.pop()

				pcb.tos = pcb.stack[-1]

				# Goal symbol reduced, and stack is empty?
				if pcb.lhs == @@goal and len(pcb.stack) == 1:
					self._clear_input(pcb)
					break

				self._get_go(pcb)

				pcb.tos = @@prefixParserToken()
				pcb.stack.append(pcb.tos)

				pcb.tos.symbol = self._symbols[pcb.lhs]
				pcb.tos.state = -1 if pcb.act &amp; self._REDUCE else pcb.idx
				pcb.tos.line = pcb.line
				pcb.tos.column = pcb.column
				pcb.tos.value = pcb.ret

			if pcb.act &amp; self._REDUCE and pcb.idx == @@goal-production:
				break

		return pcb.ret

@@epilogue

if __name__ == "__main__":
	import sys

	p = @@prefixParser()
	p.parse(sys.argv[1] if len(sys.argv) &gt; 1 else None)

</file>
</generator>
